# 5.2 è®¾è®¡æ¨¡å¼ä¸ä»£ç å®è·µ

**ç°ä»£è½¯ä»¶è®¾è®¡æ¨¡å¼çš„å½¢å¼åŒ–åˆ†æä¸å®è·µæŒ‡å—**

---

## ğŸ¯ æ¦‚è§ˆ

è®¾è®¡æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­ç»è¿‡éªŒè¯çš„è§£å†³æ–¹æ¡ˆæ¨¡æ¿ï¼Œæœ¬æ–‡æ¡£æ¢è®¨ç»å…¸ä¸ç°ä»£è®¾è®¡æ¨¡å¼åœ¨å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨ï¼Œç»“åˆå½¢å¼åŒ–æ–¹æ³•æä¾›æ·±åº¦åˆ†æã€‚

---

## ğŸ“š ç»å…¸è®¾è®¡æ¨¡å¼é‡è®¿

### ğŸ—ï¸ åˆ›å»ºå‹æ¨¡å¼

#### å•ä¾‹æ¨¡å¼ (Singleton)

```rust
use std::sync::{Arc, Mutex, Once};

pub struct Singleton {
    data: String,
}

impl Singleton {
    fn new() -> Self {
        Singleton {
            data: "Singleton Instance".to_string(),
        }
    }
    
    pub fn instance() -> Arc<Mutex<Singleton>> {
        static mut SINGLETON: Option<Arc<Mutex<Singleton>>> = None;
        static ONCE: Once = Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                SINGLETON = Some(Arc::new(Mutex::new(Singleton::new())));
            });
            SINGLETON.clone().unwrap()
        }
    }
}
```

#### å·¥å‚æ¨¡å¼ (Factory)

```lean
-- Leanä¸­çš„æŠ½è±¡å·¥å‚æ¨¡å¼
structure Product (Î± : Type) where
  create : Î±
  validate : Î± â†’ Bool

class ProductFactory (Î± Î² : Type) where
  createProduct : Î± â†’ Product Î²
  
-- å…·ä½“å®ç°
instance : ProductFactory String Nat where
  createProduct s := {
    create := s.length,
    validate := fun n => n > 0
  }
```

### ğŸ”— ç»“æ„å‹æ¨¡å¼

#### é€‚é…å™¨æ¨¡å¼ (Adapter)

```haskell
-- Haskellä¸­çš„é€‚é…å™¨æ¨¡å¼
class Adaptee a where
  specificRequest :: a -> String

class Target a where
  request :: a -> String

-- é€‚é…å™¨å®ç°
newtype Adapter a = Adapter a

instance Adaptee a => Target (Adapter a) where
  request (Adapter a) = "Adapted: " ++ specificRequest a
```

#### è£…é¥°å™¨æ¨¡å¼ (Decorator)

```python
from abc import ABC, abstractmethod
from typing import Protocol

class Component(Protocol):
    def operation(self) -> str: ...

class ConcreteComponent:
    def operation(self) -> str:
        return "ConcreteComponent"

class Decorator:
    def __init__(self, component: Component):
        self._component = component
    
    def operation(self) -> str:
        return self._component.operation()

class ConcreteDecorator(Decorator):
    def operation(self) -> str:
        return f"ConcreteDecorator({super().operation()})"
```

### ğŸ­ è¡Œä¸ºå‹æ¨¡å¼

#### è§‚å¯Ÿè€…æ¨¡å¼ (Observer)

```rust
use std::rc::Rc;
use std::cell::RefCell;

trait Observer {
    fn update(&self, data: &str);
}

struct Subject {
    observers: Vec<Rc<dyn Observer>>,
    state: String,
}

impl Subject {
    fn new() -> Self {
        Subject {
            observers: Vec::new(),
            state: String::new(),
        }
    }
    
    fn attach(&mut self, observer: Rc<dyn Observer>) {
        self.observers.push(observer);
    }
    
    fn notify(&self) {
        for observer in &self.observers {
            observer.update(&self.state);
        }
    }
    
    fn set_state(&mut self, state: String) {
        self.state = state;
        self.notify();
    }
}
```

---

## ğŸš€ ç°ä»£è®¾è®¡æ¨¡å¼

### âš¡ å“åº”å¼ç¼–ç¨‹æ¨¡å¼

#### ååº”å¼æµ (Reactive Streams)

```rust
use futures::stream::{Stream, StreamExt};
use tokio::sync::mpsc;

pub struct ReactiveStream<T> {
    receiver: mpsc::UnboundedReceiver<T>,
}

impl<T> ReactiveStream<T> {
    pub fn new() -> (Self, mpsc::UnboundedSender<T>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        (ReactiveStream { receiver }, sender)
    }
    
    pub async fn map<U, F>(mut self, f: F) -> ReactiveStream<U>
    where
        F: Fn(T) -> U + Send + 'static,
        T: Send + 'static,
        U: Send + 'static,
    {
        let (new_stream, sender) = ReactiveStream::new();
        
        tokio::spawn(async move {
            while let Some(item) = self.receiver.recv().await {
                let _ = sender.send(f(item));
            }
        });
        
        new_stream
    }
}
```

### ğŸŒ å¾®æœåŠ¡æ¨¡å¼

#### æ–­è·¯å™¨æ¨¡å¼ (Circuit Breaker)

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_count: Arc<Mutex<u32>>,
    failure_threshold: u32,
    timeout: Duration,
    last_failure_time: Arc<Mutex<Option<Instant>>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, timeout: Duration) -> Self {
        CircuitBreaker {
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: Arc::new(Mutex::new(0)),
            failure_threshold,
            timeout,
            last_failure_time: Arc::new(Mutex::new(None)),
        }
    }
    
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, E>
    where
        F: std::future::Future<Output = Result<T, E>>,
    {
        if self.is_open() {
            return Err(self.circuit_open_error());
        }
        
        match f.await {
            Ok(result) => {
                self.on_success();
                Ok(result)
            }
            Err(err) => {
                self.on_failure();
                Err(err)
            }
        }
    }
    
    fn is_open(&self) -> bool {
        let state = self.state.lock().unwrap();
        matches!(*state, CircuitState::Open)
    }
    
    fn on_success(&self) {
        let mut failure_count = self.failure_count.lock().unwrap();
        *failure_count = 0;
        
        let mut state = self.state.lock().unwrap();
        *state = CircuitState::Closed;
    }
    
    fn on_failure(&self) {
        let mut failure_count = self.failure_count.lock().unwrap();
        *failure_count += 1;
        
        if *failure_count >= self.failure_threshold {
            let mut state = self.state.lock().unwrap();
            *state = CircuitState::Open;
            
            let mut last_failure = self.last_failure_time.lock().unwrap();
            *last_failure = Some(Instant::now());
        }
    }
}
```

---

## ğŸ”„ å‡½æ•°å¼è®¾è®¡æ¨¡å¼

### ğŸ“¦ å•å­æ¨¡å¼ (Monad Pattern)

```haskell
-- Maybeå•å­å®ç°
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)

instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    Just f <*> x = fmap f x

instance Monad Maybe where
    return = pure
    Nothing >>= _ = Nothing
    Just x >>= f = f x

-- ä½¿ç”¨ç¤ºä¾‹
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

computation :: Double -> Double -> Double -> Maybe Double
computation x y z = do
    result1 <- safeDivide x y
    result2 <- safeDivide result1 z
    return result2
```

### ğŸ”§ ç»„åˆå™¨æ¨¡å¼ (Combinator Pattern)

```lean
-- Leanä¸­çš„è§£æå™¨ç»„åˆå™¨
structure Parser (Î± : Type) where
  parse : String â†’ Option (Î± Ã— String)

def pure {Î± : Type} (a : Î±) : Parser Î± :=
  { parse := fun s => some (a, s) }

def bind {Î± Î² : Type} (p : Parser Î±) (f : Î± â†’ Parser Î²) : Parser Î² :=
  { parse := fun s => 
      match p.parse s with
      | none => none
      | some (a, s') => (f a).parse s' }

def alt {Î± : Type} (p1 p2 : Parser Î±) : Parser Î± :=
  { parse := fun s =>
      match p1.parse s with
      | some result => some result
      | none => p2.parse s }
```

---

## ğŸ—ï¸ æ¶æ„æ¨¡å¼

### ğŸ¯ å…­è¾¹å½¢æ¶æ„ (Hexagonal Architecture)

```rust
// é¢†åŸŸå±‚
pub trait UserRepository {
    async fn find_by_id(&self, id: UserId) -> Option<User>;
    async fn save(&self, user: User) -> Result<(), Error>;
}

// åº”ç”¨æœåŠ¡å±‚
pub struct UserService<R: UserRepository> {
    repository: R,
}

impl<R: UserRepository> UserService<R> {
    pub fn new(repository: R) -> Self {
        UserService { repository }
    }
    
    pub async fn get_user(&self, id: UserId) -> Result<User, Error> {
        self.repository
            .find_by_id(id)
            .await
            .ok_or(Error::UserNotFound)
    }
}

// åŸºç¡€è®¾æ–½å±‚
pub struct PostgresUserRepository {
    pool: sqlx::PgPool,
}

#[async_trait::async_trait]
impl UserRepository for PostgresUserRepository {
    async fn find_by_id(&self, id: UserId) -> Option<User> {
        // æ•°æ®åº“å®ç°
        todo!()
    }
    
    async fn save(&self, user: User) -> Result<(), Error> {
        // æ•°æ®åº“å®ç°
        todo!()
    }
}
```

### ğŸŒŠ äº‹ä»¶é©±åŠ¨æ¶æ„ (Event-Driven Architecture)

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
import asyncio

class Event(ABC):
    @property
    @abstractmethod
    def event_type(self) -> str:
        pass

class EventHandler(ABC):
    @abstractmethod
    async def handle(self, event: Event) -> None:
        pass

class EventBus:
    def __init__(self):
        self._handlers: Dict[str, List[EventHandler]] = {}
    
    def subscribe(self, event_type: str, handler: EventHandler):
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
    
    async def publish(self, event: Event):
        handlers = self._handlers.get(event.event_type, [])
        await asyncio.gather(*[
            handler.handle(event) for handler in handlers
        ])

# å…·ä½“äº‹ä»¶
class UserCreatedEvent(Event):
    def __init__(self, user_id: str, email: str):
        self.user_id = user_id
        self.email = email
    
    @property
    def event_type(self) -> str:
        return "user.created"

# äº‹ä»¶å¤„ç†å™¨
class EmailNotificationHandler(EventHandler):
    async def handle(self, event: Event) -> None:
        if isinstance(event, UserCreatedEvent):
            print(f"Sending welcome email to {event.email}")
```

---

## ğŸ§© å¹¶å‘è®¾è®¡æ¨¡å¼

### ğŸ”„ Actoræ¨¡å¼

```rust
use tokio::sync::mpsc;
use std::collections::HashMap;

pub struct Message {
    pub content: String,
    pub sender: String,
}

pub struct Actor {
    id: String,
    receiver: mpsc::UnboundedReceiver<Message>,
    state: HashMap<String, String>,
}

impl Actor {
    pub fn new(id: String) -> (Self, mpsc::UnboundedSender<Message>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        let actor = Actor {
            id,
            receiver,
            state: HashMap::new(),
        };
        (actor, sender)
    }
    
    pub async fn run(mut self) {
        while let Some(message) = self.receiver.recv().await {
            self.handle_message(message).await;
        }
    }
    
    async fn handle_message(&mut self, message: Message) {
        println!("Actor {} received: {}", self.id, message.content);
        self.state.insert(message.sender, message.content);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    let (actor, sender) = Actor::new("actor1".to_string());
    
    tokio::spawn(async move {
        actor.run().await;
    });
    
    sender.send(Message {
        content: "Hello Actor!".to_string(),
        sender: "main".to_string(),
    }).unwrap();
}
```

### ğŸ” è½¯ä»¶äº‹åŠ¡å†…å­˜ (STM)

```haskell
import Control.Concurrent.STM

data Account = Account { balance :: TVar Int }

transfer :: Account -> Account -> Int -> STM ()
transfer from to amount = do
    fromBalance <- readTVar (balance from)
    if fromBalance >= amount
        then do
            writeTVar (balance from) (fromBalance - amount)
            toBalance <- readTVar (balance to)
            writeTVar (balance to) (toBalance + amount)
        else retry

-- ä½¿ç”¨äº‹åŠ¡
main :: IO ()
main = do
    account1 <- Account <$> newTVarIO 1000
    account2 <- Account <$> newTVarIO 500
    
    atomically $ transfer account1 account2 200
    
    balance1 <- readTVarIO (balance account1)
    balance2 <- readTVarIO (balance account2)
    putStrLn $ "Account 1: " ++ show balance1
    putStrLn $ "Account 2: " ++ show balance2
```

---

## ğŸ“Š æ€»ç»“ä¸æœ€ä½³å®è·µ

### ğŸ¯ æ¨¡å¼é€‰æ‹©æŒ‡å—

1. **åˆ›å»ºå‹æ¨¡å¼**: å¯¹è±¡åˆ›å»ºå¤æ‚æ€§ç®¡ç†
2. **ç»“æ„å‹æ¨¡å¼**: å¯¹è±¡ç»„åˆä¸æ¥å£é€‚é…
3. **è¡Œä¸ºå‹æ¨¡å¼**: å¯¹è±¡é—´é€šä¿¡ä¸èŒè´£åˆ†é…
4. **ç°ä»£æ¨¡å¼**: å¾®æœåŠ¡ã€å“åº”å¼ç¼–ç¨‹éœ€æ±‚
5. **å‡½æ•°å¼æ¨¡å¼**: ä¸å¯å˜æ€§ä¸ç»„åˆæ€§

### ğŸš€ å®è·µå»ºè®®

- ğŸ“‹ **éœ€æ±‚é©±åŠ¨**: æ ¹æ®å®é™…é—®é¢˜é€‰æ‹©æ¨¡å¼
- ğŸ”§ **æ¸è¿›å¼é‡‡ç”¨**: ä»ç®€å•æ¨¡å¼å¼€å§‹
- ğŸ“Š **æ€§èƒ½è€ƒé‡**: æƒè¡¡æ¨¡å¼å¤æ‚æ€§ä¸æ€§èƒ½
- ğŸŒ **å›¢é˜Ÿåä½œ**: å»ºç«‹å…±åŒçš„æ¨¡å¼è¯æ±‡
- ğŸ“š **æŒç»­å­¦ä¹ **: è·Ÿè¸ªæ–°å…´æ¨¡å¼è¶‹åŠ¿

---

*æ–‡æ¡£ç‰ˆæœ¬: v1.2*  
*æœ€åæ›´æ–°: 2024å¹´12æœˆ*  
*è´¨é‡ç­‰çº§: é«˜è´¨é‡å®è·µæŒ‡å—*

---

## ğŸ” å½¢å¼åŒ–éªŒè¯ä¸è®¾è®¡æ¨¡å¼

### ğŸ“ è®¾è®¡æ¨¡å¼çš„å½¢å¼åŒ–è§„èŒƒ

```lean
-- Lean å½¢å¼åŒ–ï¼šè®¾è®¡æ¨¡å¼è§„èŒƒ
structure DesignPattern (Î± Î² : Type) where
  name : String
  intent : String
  participants : List String
  collaboration : String
  consequences : List String
  implementation : Î± â†’ Î²

-- å•ä¾‹æ¨¡å¼çš„å½¢å¼åŒ–å®šä¹‰
def singleton_pattern : DesignPattern Unit (Unit â†’ Unit) := {
  name := "Singleton",
  intent := "ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›å…¨å±€è®¿é—®ç‚¹",
  participants := ["Singleton"],
  collaboration := "å®¢æˆ·ç«¯é€šè¿‡getInstance()è®¿é—®å”¯ä¸€å®ä¾‹",
  consequences := [
    "ä¿è¯ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹",
    "æä¾›å…¨å±€è®¿é—®ç‚¹",
    "å»¶è¿Ÿåˆå§‹åŒ–"
  ],
  implementation := fun _ => fun _ => ()
}

-- è§‚å¯Ÿè€…æ¨¡å¼çš„å½¢å¼åŒ–å®šä¹‰
structure Observer (Î± : Type) where
  update : Î± â†’ Unit

structure Subject (Î± : Type) where
  observers : List (Observer Î±)
  state : Î±
  attach : Observer Î± â†’ Subject Î±
  detach : Observer Î± â†’ Subject Î±
  notify : Subject Î± â†’ Subject Î±

def observer_pattern : DesignPattern (Subject Î±) (List (Observer Î±)) := {
  name := "Observer",
  intent := "å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³»",
  participants := ["Subject", "Observer", "ConcreteSubject", "ConcreteObserver"],
  collaboration := "Subjecté€šçŸ¥ObserverçŠ¶æ€å˜åŒ–",
  consequences := [
    "æ”¯æŒå¹¿æ’­é€šä¿¡",
    "æ¾è€¦åˆ",
    "å¯èƒ½äº§ç”Ÿæ„å¤–çš„æ›´æ–°"
  ],
  implementation := fun subject => subject.observers
}
```

### ğŸ”’ è®¾è®¡æ¨¡å¼çš„ä¸å˜é‡éªŒè¯

```rust
use std::collections::HashMap;

// è®¾è®¡æ¨¡å¼ä¸å˜é‡éªŒè¯æ¡†æ¶
pub trait DesignPatternInvariant {
    fn verify_invariant(&self) -> bool;
    fn invariant_description(&self) -> &'static str;
}

// å•ä¾‹æ¨¡å¼ä¸å˜é‡
pub struct SingletonInvariant {
    instance_count: std::sync::atomic::AtomicUsize,
}

impl DesignPatternInvariant for SingletonInvariant {
    fn verify_invariant(&self) -> bool {
        // å•ä¾‹æ¨¡å¼ä¸å˜é‡ï¼šå®ä¾‹æ•°é‡å¿…é¡»ä¸º1
        self.instance_count.load(std::sync::atomic::Ordering::Relaxed) == 1
    }
    
    fn invariant_description(&self) -> &'static str {
        "Singleton pattern invariant: exactly one instance must exist"
    }
}

// è§‚å¯Ÿè€…æ¨¡å¼ä¸å˜é‡
pub struct ObserverInvariant {
    subject_state: String,
    observer_count: usize,
    notification_count: usize,
}

impl DesignPatternInvariant for ObserverInvariant {
    fn verify_invariant(&self) -> bool {
        // è§‚å¯Ÿè€…æ¨¡å¼ä¸å˜é‡ï¼šæ‰€æœ‰è§‚å¯Ÿè€…éƒ½åº”è¯¥è¢«é€šçŸ¥
        self.notification_count >= self.observer_count
    }
    
    fn invariant_description(&self) -> &'static str {
        "Observer pattern invariant: all observers must be notified of state changes"
    }
}

// è®¾è®¡æ¨¡å¼éªŒè¯å™¨
pub struct PatternValidator {
    invariants: Vec<Box<dyn DesignPatternInvariant>>,
}

impl PatternValidator {
    pub fn new() -> Self {
        Self {
            invariants: Vec::new(),
        }
    }
    
    pub fn add_invariant(&mut self, invariant: Box<dyn DesignPatternInvariant>) {
        self.invariants.push(invariant);
    }
    
    pub fn verify_all(&self) -> Vec<ValidationResult> {
        self.invariants
            .iter()
            .map(|invariant| {
                let is_valid = invariant.verify_invariant();
                ValidationResult {
                    pattern_name: std::any::type_name::<dyn DesignPatternInvariant>(),
                    invariant_description: invariant.invariant_description(),
                    is_valid,
                }
            })
            .collect()
    }
}

#[derive(Debug)]
pub struct ValidationResult {
    pattern_name: &'static str,
    invariant_description: &'static str,
    is_valid: bool,
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–è®¾è®¡æ¨¡å¼

### ğŸš€ ç¼“å­˜æ¨¡å¼ (Cache Pattern)

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

pub struct CacheEntry<T> {
    value: T,
    created_at: Instant,
    ttl: Duration,
}

impl<T> CacheEntry<T> {
    fn is_expired(&self) -> bool {
        self.created_at.elapsed() > self.ttl
    }
}

pub struct Cache<T> {
    storage: Arc<RwLock<HashMap<String, CacheEntry<T>>>>,
    max_size: usize,
}

impl<T: Clone> Cache<T> {
    pub fn new(max_size: usize) -> Self {
        Self {
            storage: Arc::new(RwLock::new(HashMap::new())),
            max_size,
        }
    }
    
    pub fn get(&self, key: &str) -> Option<T> {
        let storage = self.storage.read().unwrap();
        if let Some(entry) = storage.get(key) {
            if !entry.is_expired() {
                return Some(entry.value.clone());
            }
        }
        None
    }
    
    pub fn set(&self, key: String, value: T, ttl: Duration) {
        let mut storage = self.storage.write().unwrap();
        
        // æ¸…ç†è¿‡æœŸæ¡ç›®
        storage.retain(|_, entry| !entry.is_expired());
        
        // å¦‚æœè¾¾åˆ°æœ€å¤§å¤§å°ï¼Œç§»é™¤æœ€æ—§çš„æ¡ç›®
        if storage.len() >= self.max_size {
            let oldest_key = storage
                .iter()
                .min_by_key(|(_, entry)| entry.created_at)
                .map(|(k, _)| k.clone());
            
            if let Some(key_to_remove) = oldest_key {
                storage.remove(&key_to_remove);
            }
        }
        
        let entry = CacheEntry {
            value,
            created_at: Instant::now(),
            ttl,
        };
        
        storage.insert(key, entry);
    }
}

// ç¼“å­˜è£…é¥°å™¨æ¨¡å¼
pub struct CachedService<S, T> {
    service: S,
    cache: Cache<T>,
}

impl<S, T> CachedService<S, T>
where
    S: Service<T>,
    T: Clone,
{
    pub fn new(service: S, cache_size: usize) -> Self {
        Self {
            service,
            cache: Cache::new(cache_size),
        }
    }
    
    pub async fn get_cached(&self, key: &str) -> Option<T> {
        // å…ˆå°è¯•ä»ç¼“å­˜è·å–
        if let Some(cached_value) = self.cache.get(key) {
            return Some(cached_value);
        }
        
        // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æœåŠ¡è·å–
        if let Some(value) = self.service.get(key).await {
            self.cache.set(key.to_string(), value.clone(), Duration::from_secs(300));
            return Some(value);
        }
        
        None
    }
}

pub trait Service<T> {
    async fn get(&self, key: &str) -> Option<T>;
}
```

### ğŸ”„ å¼‚æ­¥æ¨¡å¼ (Async Pattern)

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio::sync::mpsc;

// å¼‚æ­¥è¿­ä»£å™¨æ¨¡å¼
pub struct AsyncIterator<T> {
    receiver: mpsc::UnboundedReceiver<T>,
}

impl<T> AsyncIterator<T> {
    pub fn new() -> (Self, mpsc::UnboundedSender<T>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        (Self { receiver }, sender)
    }
}

impl<T> Future for AsyncIterator<T> {
    type Output = Option<T>;
    
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        match self.receiver.poll_recv(cx) {
            Poll::Ready(Some(value)) => Poll::Ready(Some(value)),
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Pending => Poll::Pending,
        }
    }
}

// å¼‚æ­¥ç®¡é“æ¨¡å¼
pub struct AsyncPipeline<I, O> {
    stages: Vec<Box<dyn PipelineStage<I, O> + Send + Sync>>,
}

impl<I, O> AsyncPipeline<I, O> {
    pub fn new() -> Self {
        Self {
            stages: Vec::new(),
        }
    }
    
    pub fn add_stage<S>(mut self, stage: S) -> Self
    where
        S: PipelineStage<I, O> + Send + Sync + 'static,
    {
        self.stages.push(Box::new(stage));
        self
    }
    
    pub async fn process(&self, input: I) -> Result<O, PipelineError> {
        let mut current = input;
        
        for stage in &self.stages {
            current = stage.process(current).await?;
        }
        
        Ok(current)
    }
}

pub trait PipelineStage<I, O> {
    async fn process(&self, input: I) -> Result<O, PipelineError>;
}

#[derive(Debug)]
pub enum PipelineError {
    ProcessingError(String),
    ValidationError(String),
}
```

## ğŸ¯ æœ€ä½³å®è·µä¸è®¾è®¡åŸåˆ™

### ğŸ“‹ SOLIDåŸåˆ™çš„å½¢å¼åŒ–è¡¨è¾¾

```lean
-- Lean å½¢å¼åŒ–ï¼šSOLIDåŸåˆ™
-- å•ä¸€èŒè´£åŸåˆ™ (Single Responsibility Principle)
structure SingleResponsibility (Î± : Type) where
  responsibility : String
  implementation : Î±
  -- æ¯ä¸ªç±»åº”è¯¥åªæœ‰ä¸€ä¸ªæ”¹å˜çš„ç†ç”±

-- å¼€é—­åŸåˆ™ (Open/Closed Principle)
structure OpenClosed (Î± Î² : Type) where
  base : Î±
  extension : Î± â†’ Î²
  -- å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­

-- é‡Œæ°æ›¿æ¢åŸåˆ™ (Liskov Substitution Principle)
class LiskovSubstitution (Î± Î² : Type) where
  subtype : Î± â†’ Î²
  -- å­ç±»å‹å¿…é¡»èƒ½å¤Ÿæ›¿æ¢å…¶åŸºç±»å‹

-- æ¥å£éš”ç¦»åŸåˆ™ (Interface Segregation Principle)
structure InterfaceSegregation (Î± : Type) where
  minimal_interface : List String
  -- å®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸ä½¿ç”¨çš„æ¥å£

-- ä¾èµ–å€’ç½®åŸåˆ™ (Dependency Inversion Principle)
structure DependencyInversion (Î± Î² : Type) where
  abstraction : Î±
  implementation : Î²
  -- é«˜å±‚æ¨¡å—ä¸åº”è¯¥ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½åº”è¯¥ä¾èµ–æŠ½è±¡

-- SOLIDåŸåˆ™éªŒè¯
theorem solid_principles_consistency 
  (Î± Î² : Type) 
  (sr : SingleResponsibility Î±)
  (oc : OpenClosed Î± Î²)
  (ls : LiskovSubstitution Î± Î²)
  (is : InterfaceSegregation Î±)
  (di : DependencyInversion Î± Î²) :
  -- SOLIDåŸåˆ™ä¹‹é—´çš„ä¸€è‡´æ€§
  true := by
  sorry
```

### ğŸ”§ è®¾è®¡æ¨¡å¼é€‰æ‹©æŒ‡å—

```rust
// è®¾è®¡æ¨¡å¼é€‰æ‹©å†³ç­–æ ‘
pub enum DesignPatternType {
    Creational,
    Structural,
    Behavioral,
    Concurrency,
    Architectural,
}

pub struct PatternSelectionCriteria {
    problem_type: ProblemType,
    performance_requirements: PerformanceRequirements,
    maintainability_requirements: MaintainabilityRequirements,
    team_expertise: TeamExpertise,
}

pub enum ProblemType {
    ObjectCreation,
    ObjectComposition,
    ObjectCommunication,
    ConcurrencyControl,
    SystemArchitecture,
}

pub struct PerformanceRequirements {
    latency_ms: u64,
    throughput_rps: u64,
    memory_mb: u64,
}

pub struct MaintainabilityRequirements {
    code_complexity: f32,
    test_coverage: f32,
    documentation_quality: f32,
}

pub struct TeamExpertise {
    rust_experience: f32,
    design_patterns_knowledge: f32,
    domain_knowledge: f32,
}

impl PatternSelectionCriteria {
    pub fn recommend_patterns(&self) -> Vec<RecommendedPattern> {
        let mut recommendations = Vec::new();
        
        match self.problem_type {
            ProblemType::ObjectCreation => {
                if self.performance_requirements.latency_ms < 10 {
                    recommendations.push(RecommendedPattern::Singleton);
                } else {
                    recommendations.push(RecommendedPattern::Factory);
                }
            }
            ProblemType::ObjectComposition => {
                if self.maintainability_requirements.code_complexity < 0.5 {
                    recommendations.push(RecommendedPattern::Adapter);
                } else {
                    recommendations.push(RecommendedPattern::Decorator);
                }
            }
            ProblemType::ObjectCommunication => {
                if self.team_expertise.rust_experience > 0.8 {
                    recommendations.push(RecommendedPattern::Observer);
                } else {
                    recommendations.push(RecommendedPattern::Command);
                }
            }
            ProblemType::ConcurrencyControl => {
                if self.performance_requirements.throughput_rps > 1000 {
                    recommendations.push(RecommendedPattern::Actor);
                } else {
                    recommendations.push(RecommendedPattern::Lock);
                }
            }
            ProblemType::SystemArchitecture => {
                if self.maintainability_requirements.test_coverage > 0.8 {
                    recommendations.push(RecommendedPattern::Hexagonal);
                } else {
                    recommendations.push(RecommendedPattern::Layered);
                }
            }
        }
        
        recommendations
    }
}

#[derive(Debug)]
pub enum RecommendedPattern {
    Singleton,
    Factory,
    Adapter,
    Decorator,
    Observer,
    Command,
    Actor,
    Lock,
    Hexagonal,
    Layered,
}
```

---

## äº¤å‰å¼•ç”¨

### ç›¸å…³ä¸»é¢˜

- [5.1-æ¶æ„è®¾è®¡ä¸å½¢å¼åŒ–åˆ†æ](./5.1-æ¶æ„è®¾è®¡ä¸å½¢å¼åŒ–åˆ†æ.md)
- [5.x-å…¶ä»–æ¶æ„ä¸»é¢˜](./5.x-å…¶ä»–æ¶æ„ä¸»é¢˜.md)
- [6.1-leanè¯­è¨€ä¸å½¢å¼åŒ–è¯æ˜](../6-ç¼–ç¨‹è¯­è¨€ä¸å®ç°/6.1-leanè¯­è¨€ä¸å½¢å¼åŒ–è¯æ˜.md)
- [7.1-å½¢å¼åŒ–éªŒè¯æ¶æ„](../7-éªŒè¯ä¸å·¥ç¨‹å®è·µ/7.1-å½¢å¼åŒ–éªŒè¯æ¶æ„.md)

### æœ¬åœ°å¯¼èˆª

- [è¿”å›æ¶æ„ä¸è®¾è®¡æ¨¡å¼ä¸»é¡µ](../5-æ¶æ„ä¸è®¾è®¡æ¨¡å¼.md)

### å‚è€ƒæ–‡çŒ®

#### æƒå¨æ–‡çŒ®

- [1] Gamma, E., et al. "Design Patterns: Elements of Reusable Object-Oriented Software." Addison-Wesley, 1994.
- [2] Freeman, E., et al. "Head First Design Patterns." O'Reilly, 2004.
- [3] Martin, R.C. "Clean Architecture: A Craftsman's Guide to Software Structure and Design." Prentice Hall, 2017.

#### åœ¨çº¿èµ„æº

- [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
- [Haskell Design Patterns](https://wiki.haskell.org/Design_patterns)
- [Lean 4 Documentation](https://leanprover.github.io/lean4/doc/)

#### å»¶ä¼¸é˜…è¯»

- [å‡½æ•°å¼ç¼–ç¨‹è®¾è®¡æ¨¡å¼](https://www.manning.com/books/functional-programming-in-scala)
- [å¹¶å‘ç¼–ç¨‹æ¨¡å¼](https://www.oreilly.com/library/view/java-concurrency-in/9780137001291/)
- [å¾®æœåŠ¡è®¾è®¡æ¨¡å¼](https://www.manning.com/books/microservices-patterns)

---

[è¿”å›ç›®å½•](../0-æ€»è§ˆä¸å¯¼èˆª/0.1-å…¨å±€ä¸»é¢˜æ ‘å½¢ç›®å½•.md)

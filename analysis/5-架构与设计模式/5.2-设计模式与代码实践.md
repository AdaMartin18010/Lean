# 5.2 设计模式与代码实践

**现代软件设计模式的形式化分析与实践指南**

---

## 🎯 概览

设计模式是软件工程中经过验证的解决方案模板，本文档探讨经典与现代设计模式在实际项目中的应用，结合形式化方法提供深度分析。

---

## 📚 经典设计模式重访

### 🏗️ 创建型模式

#### 单例模式 (Singleton)

```rust
use std::sync::{Arc, Mutex, Once};

pub struct Singleton {
    data: String,
}

impl Singleton {
    fn new() -> Self {
        Singleton {
            data: "Singleton Instance".to_string(),
        }
    }
    
    pub fn instance() -> Arc<Mutex<Singleton>> {
        static mut SINGLETON: Option<Arc<Mutex<Singleton>>> = None;
        static ONCE: Once = Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                SINGLETON = Some(Arc::new(Mutex::new(Singleton::new())));
            });
            SINGLETON.clone().unwrap()
        }
    }
}
```

#### 工厂模式 (Factory)

```lean
-- Lean中的抽象工厂模式
structure Product (α : Type) where
  create : α
  validate : α → Bool

class ProductFactory (α β : Type) where
  createProduct : α → Product β
  
-- 具体实现
instance : ProductFactory String Nat where
  createProduct s := {
    create := s.length,
    validate := fun n => n > 0
  }
```

### 🔗 结构型模式

#### 适配器模式 (Adapter)

```haskell
-- Haskell中的适配器模式
class Adaptee a where
  specificRequest :: a -> String

class Target a where
  request :: a -> String

-- 适配器实现
newtype Adapter a = Adapter a

instance Adaptee a => Target (Adapter a) where
  request (Adapter a) = "Adapted: " ++ specificRequest a
```

#### 装饰器模式 (Decorator)

```python
from abc import ABC, abstractmethod
from typing import Protocol

class Component(Protocol):
    def operation(self) -> str: ...

class ConcreteComponent:
    def operation(self) -> str:
        return "ConcreteComponent"

class Decorator:
    def __init__(self, component: Component):
        self._component = component
    
    def operation(self) -> str:
        return self._component.operation()

class ConcreteDecorator(Decorator):
    def operation(self) -> str:
        return f"ConcreteDecorator({super().operation()})"
```

### 🎭 行为型模式

#### 观察者模式 (Observer)

```rust
use std::rc::Rc;
use std::cell::RefCell;

trait Observer {
    fn update(&self, data: &str);
}

struct Subject {
    observers: Vec<Rc<dyn Observer>>,
    state: String,
}

impl Subject {
    fn new() -> Self {
        Subject {
            observers: Vec::new(),
            state: String::new(),
        }
    }
    
    fn attach(&mut self, observer: Rc<dyn Observer>) {
        self.observers.push(observer);
    }
    
    fn notify(&self) {
        for observer in &self.observers {
            observer.update(&self.state);
        }
    }
    
    fn set_state(&mut self, state: String) {
        self.state = state;
        self.notify();
    }
}
```

---

## 🚀 现代设计模式

### ⚡ 响应式编程模式

#### 反应式流 (Reactive Streams)

```rust
use futures::stream::{Stream, StreamExt};
use tokio::sync::mpsc;

pub struct ReactiveStream<T> {
    receiver: mpsc::UnboundedReceiver<T>,
}

impl<T> ReactiveStream<T> {
    pub fn new() -> (Self, mpsc::UnboundedSender<T>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        (ReactiveStream { receiver }, sender)
    }
    
    pub async fn map<U, F>(mut self, f: F) -> ReactiveStream<U>
    where
        F: Fn(T) -> U + Send + 'static,
        T: Send + 'static,
        U: Send + 'static,
    {
        let (new_stream, sender) = ReactiveStream::new();
        
        tokio::spawn(async move {
            while let Some(item) = self.receiver.recv().await {
                let _ = sender.send(f(item));
            }
        });
        
        new_stream
    }
}
```

### 🌐 微服务模式

#### 断路器模式 (Circuit Breaker)

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_count: Arc<Mutex<u32>>,
    failure_threshold: u32,
    timeout: Duration,
    last_failure_time: Arc<Mutex<Option<Instant>>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, timeout: Duration) -> Self {
        CircuitBreaker {
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: Arc::new(Mutex::new(0)),
            failure_threshold,
            timeout,
            last_failure_time: Arc::new(Mutex::new(None)),
        }
    }
    
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, E>
    where
        F: std::future::Future<Output = Result<T, E>>,
    {
        if self.is_open() {
            return Err(self.circuit_open_error());
        }
        
        match f.await {
            Ok(result) => {
                self.on_success();
                Ok(result)
            }
            Err(err) => {
                self.on_failure();
                Err(err)
            }
        }
    }
    
    fn is_open(&self) -> bool {
        let state = self.state.lock().unwrap();
        matches!(*state, CircuitState::Open)
    }
    
    fn on_success(&self) {
        let mut failure_count = self.failure_count.lock().unwrap();
        *failure_count = 0;
        
        let mut state = self.state.lock().unwrap();
        *state = CircuitState::Closed;
    }
    
    fn on_failure(&self) {
        let mut failure_count = self.failure_count.lock().unwrap();
        *failure_count += 1;
        
        if *failure_count >= self.failure_threshold {
            let mut state = self.state.lock().unwrap();
            *state = CircuitState::Open;
            
            let mut last_failure = self.last_failure_time.lock().unwrap();
            *last_failure = Some(Instant::now());
        }
    }
}
```

---

## 🔄 函数式设计模式

### 📦 单子模式 (Monad Pattern)

```haskell
-- Maybe单子实现
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)

instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    Just f <*> x = fmap f x

instance Monad Maybe where
    return = pure
    Nothing >>= _ = Nothing
    Just x >>= f = f x

-- 使用示例
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

computation :: Double -> Double -> Double -> Maybe Double
computation x y z = do
    result1 <- safeDivide x y
    result2 <- safeDivide result1 z
    return result2
```

### 🔧 组合器模式 (Combinator Pattern)

```lean
-- Lean中的解析器组合器
structure Parser (α : Type) where
  parse : String → Option (α × String)

def pure {α : Type} (a : α) : Parser α :=
  { parse := fun s => some (a, s) }

def bind {α β : Type} (p : Parser α) (f : α → Parser β) : Parser β :=
  { parse := fun s => 
      match p.parse s with
      | none => none
      | some (a, s') => (f a).parse s' }

def alt {α : Type} (p1 p2 : Parser α) : Parser α :=
  { parse := fun s =>
      match p1.parse s with
      | some result => some result
      | none => p2.parse s }
```

---

## 🏗️ 架构模式

### 🎯 六边形架构 (Hexagonal Architecture)

```rust
// 领域层
pub trait UserRepository {
    async fn find_by_id(&self, id: UserId) -> Option<User>;
    async fn save(&self, user: User) -> Result<(), Error>;
}

// 应用服务层
pub struct UserService<R: UserRepository> {
    repository: R,
}

impl<R: UserRepository> UserService<R> {
    pub fn new(repository: R) -> Self {
        UserService { repository }
    }
    
    pub async fn get_user(&self, id: UserId) -> Result<User, Error> {
        self.repository
            .find_by_id(id)
            .await
            .ok_or(Error::UserNotFound)
    }
}

// 基础设施层
pub struct PostgresUserRepository {
    pool: sqlx::PgPool,
}

#[async_trait::async_trait]
impl UserRepository for PostgresUserRepository {
    async fn find_by_id(&self, id: UserId) -> Option<User> {
        // 数据库实现
        todo!()
    }
    
    async fn save(&self, user: User) -> Result<(), Error> {
        // 数据库实现
        todo!()
    }
}
```

### 🌊 事件驱动架构 (Event-Driven Architecture)

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
import asyncio

class Event(ABC):
    @property
    @abstractmethod
    def event_type(self) -> str:
        pass

class EventHandler(ABC):
    @abstractmethod
    async def handle(self, event: Event) -> None:
        pass

class EventBus:
    def __init__(self):
        self._handlers: Dict[str, List[EventHandler]] = {}
    
    def subscribe(self, event_type: str, handler: EventHandler):
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
    
    async def publish(self, event: Event):
        handlers = self._handlers.get(event.event_type, [])
        await asyncio.gather(*[
            handler.handle(event) for handler in handlers
        ])

# 具体事件
class UserCreatedEvent(Event):
    def __init__(self, user_id: str, email: str):
        self.user_id = user_id
        self.email = email
    
    @property
    def event_type(self) -> str:
        return "user.created"

# 事件处理器
class EmailNotificationHandler(EventHandler):
    async def handle(self, event: Event) -> None:
        if isinstance(event, UserCreatedEvent):
            print(f"Sending welcome email to {event.email}")
```

---

## 🧩 并发设计模式

### 🔄 Actor模式

```rust
use tokio::sync::mpsc;
use std::collections::HashMap;

pub struct Message {
    pub content: String,
    pub sender: String,
}

pub struct Actor {
    id: String,
    receiver: mpsc::UnboundedReceiver<Message>,
    state: HashMap<String, String>,
}

impl Actor {
    pub fn new(id: String) -> (Self, mpsc::UnboundedSender<Message>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        let actor = Actor {
            id,
            receiver,
            state: HashMap::new(),
        };
        (actor, sender)
    }
    
    pub async fn run(mut self) {
        while let Some(message) = self.receiver.recv().await {
            self.handle_message(message).await;
        }
    }
    
    async fn handle_message(&mut self, message: Message) {
        println!("Actor {} received: {}", self.id, message.content);
        self.state.insert(message.sender, message.content);
    }
}

// 使用示例
#[tokio::main]
async fn main() {
    let (actor, sender) = Actor::new("actor1".to_string());
    
    tokio::spawn(async move {
        actor.run().await;
    });
    
    sender.send(Message {
        content: "Hello Actor!".to_string(),
        sender: "main".to_string(),
    }).unwrap();
}
```

### 🔐 软件事务内存 (STM)

```haskell
import Control.Concurrent.STM

data Account = Account { balance :: TVar Int }

transfer :: Account -> Account -> Int -> STM ()
transfer from to amount = do
    fromBalance <- readTVar (balance from)
    if fromBalance >= amount
        then do
            writeTVar (balance from) (fromBalance - amount)
            toBalance <- readTVar (balance to)
            writeTVar (balance to) (toBalance + amount)
        else retry

-- 使用事务
main :: IO ()
main = do
    account1 <- Account <$> newTVarIO 1000
    account2 <- Account <$> newTVarIO 500
    
    atomically $ transfer account1 account2 200
    
    balance1 <- readTVarIO (balance account1)
    balance2 <- readTVarIO (balance account2)
    putStrLn $ "Account 1: " ++ show balance1
    putStrLn $ "Account 2: " ++ show balance2
```

---

## 📊 总结与最佳实践

### 🎯 模式选择指南

1. **创建型模式**: 对象创建复杂性管理
2. **结构型模式**: 对象组合与接口适配
3. **行为型模式**: 对象间通信与职责分配
4. **现代模式**: 微服务、响应式编程需求
5. **函数式模式**: 不可变性与组合性

### 🚀 实践建议

- 📋 **需求驱动**: 根据实际问题选择模式
- 🔧 **渐进式采用**: 从简单模式开始
- 📊 **性能考量**: 权衡模式复杂性与性能
- 🌐 **团队协作**: 建立共同的模式词汇
- 📚 **持续学习**: 跟踪新兴模式趋势

---

*文档版本: v1.2*  
*最后更新: 2024年12月*  
*质量等级: 高质量实践指南*

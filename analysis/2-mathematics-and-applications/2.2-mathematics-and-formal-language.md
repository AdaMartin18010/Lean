# 2.2 Mathematics and Formal Language

[Back to Parent](../2-mathematics-and-applications.md) | [中文版](../2-数学基础与应用/2.2-数学与形式化语言关系.md)

## Table of Contents

- [2.2 Mathematics and Formal Language](#22-mathematics-and-formal-language)
  - [Table of Contents](#table-of-contents)
  - [2.2.1 Interaction between Mathematics and Formal Language](#221-interaction-between-mathematics-and-formal-language)
  - [2.2.2 Code Example](#222-code-example)
  - [2.2.3 References](#223-references)
  - [2.2.4 Formal Language and Automata Theory Cross-References](#224-formal-language-and-automata-theory-cross-references)

---

## 2.2.1 Interaction between Mathematics and Formal Language

Mathematics and formal languages interlock at the level of foundations and mechanization:

- Set theory models collections via membership predicates; type theory models constructions via types and terms. A classic bridge is to view a set as a predicate over a universe while viewing a type as a carrier of inhabitants.
- Proofs-as-programs (Curry–Howard) connects derivations with typed terms, enabling machine-checked mathematics.

Example: sets-as-predicates vs. types-as-carriers (Lean-style pseudocode):

```lean
-- Sets-as-predicates (impredicative view)
def Set (α : Type) := α → Prop

def mem {α} (x : α) (s : Set α) : Prop := s x

-- Subset and image
def Subset {α} (s t : Set α) : Prop := ∀ x, s x → t x

def Image {α β} (f : α → β) (s : Set α) : Set β := fun y => ∃ x, s x ∧ f x = y

-- Types-as-carriers (constructive view)
-- A list is an inductive type; its values are constructive witnesses
inductive List (α : Type) : Type
| nil : List
| cons : α → List → List
```

## 2.2.2 Code Example

```lean
-- Lean pseudo-code: definition of set
inductive Set (α : Type)
| empty : Set
| insert : α → Set → Set
```

## 2.2.3 References

- "Set Theory and Type Theory" (overview text)
- "Type Theory and Formal Proof" — R. Nederpelt, H. Geuvers, 2014
- "The HoTT Book" — Univalent Foundations Program, 2013
- [Lean Community](https://leanprover-community.github.io/)
- H. Enderton, "Elements of Set Theory", 1977

## 2.2.4 Formal Language and Automata Theory Cross-References

- **Automata Theory**: [Automata Theory](../../docs/analysis0/02_Formal_Language/01_Automata_Theory.md)
- **Formal Grammar Theory**: [Formal Grammar Theory](../../docs/analysis0/02_Formal_Language/02_Formal_Grammar_Theory.md)
- **Language Hierarchy**: [Language Hierarchy](../../docs/analysis0/02_Formal_Language/03_Language_Hierarchy.md)

### Learning Path for Formal Language Theory

1. **Automata Theory Basics**: Start with [Automata Theory](../../docs/analysis0/02_Formal_Language/01_Automata_Theory.md) to understand DFA, NFA, ε-NFA, PDA, Turing machines, and their equivalence.
2. **Formal Grammar Theory**: Deepen your understanding with [Formal Grammar Theory](../../docs/analysis0/02_Formal_Language/02_Formal_Grammar_Theory.md), covering CFG, CNF, GNF, and parsing algorithms.
3. **Language Hierarchy**: Explore [Language Hierarchy](../../docs/analysis0/02_Formal_Language/03_Language_Hierarchy.md) to master the Chomsky hierarchy, pumping lemma, and closure properties.
4. **Advanced Topics**: Integrate knowledge with applications in compiler design, verification, and formal semantics.

---

[Back to Tree](../0-Overview-and-Navigation/0.1-Global-Topic-Tree.md)

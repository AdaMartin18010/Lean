# 1.5.2 Formal Grammar Theory

[Chinese Version](../1-形式化理论/1.5-形式语言与自动化理论/1.5.2-形式文法理论.md)

## Table of Contents

- [1.5.2 Formal Grammar Theory](#152-formal-grammar-theory)
  - [Table of Contents](#table-of-contents)
  - [1.5.2.1 Basic Grammar Concepts](#1521-basic-grammar-concepts)
    - [Grammar Definition](#grammar-definition)
    - [Derivation and Reduction](#derivation-and-reduction)
    - [Grammar Classification](#grammar-classification)
  - [1.5.2.2 Context-Free Grammars](#1522-context-free-grammars)
    - [CFG Definition](#cfg-definition)
    - [Parse Trees](#parse-trees)
    - [Ambiguity](#ambiguity)
  - [1.5.2.3 Parsing Algorithms](#1523-parsing-algorithms)
    - [Recursive Descent Parsing](#recursive-descent-parsing)
    - [LL Parsing](#ll-parsing)
    - [LR Parsing](#lr-parsing)
  - [1.5.2.4 Practical Application Cases](#1524-practical-application-cases)
    - [Case 1: Programming Language Syntax](#case-1-programming-language-syntax)
    - [Case 2: Natural Language Processing](#case-2-natural-language-processing)
    - [Case 3: Configuration File Parsing](#case-3-configuration-file-parsing)
  - [1.5.2.5 References](#1525-references)
    - [Classical Literature](#classical-literature)
    - [Modern Textbooks](#modern-textbooks)
    - [Online Resources](#online-resources)
    - [Further Reading](#further-reading)

## 1.5.2.1 Basic Grammar Concepts

### Grammar Definition

**Definition 1.5.2.1** (Grammar): A grammar is a 4-tuple $G = (V_N, V_T, P, S)$ where:

- $V_N$: set of non-terminals
- $V_T$: set of terminals
- $P$: set of production rules
- $S \in V_N$: start symbol

**Lean Implementation**:

```lean
-- Grammar definition
structure Grammar where
  non_terminals : Set String
  terminals : Set String
  productions : List (String × String)
  start_symbol : String
  deriving Repr

-- Production rules
inductive Production where
  | Rule : String → String → Production  -- Left → Right
  deriving Repr

-- Grammar example: simple arithmetic expressions
def simple_arithmetic_grammar : Grammar := {
  non_terminals := {"E", "T", "F"},
  terminals := {"+", "*", "(", ")", "id"},
  productions := [
    ("E", "E + T"),
    ("E", "T"),
    ("T", "T * F"),
    ("T", "F"),
    ("F", "(E)"),
    ("F", "id")
  ],
  start_symbol := "E"
}
```

### Derivation and Reduction

**Definition 1.5.2.2** (Derivation): If there exists a production $A \rightarrow \alpha$, then $\beta A \gamma \Rightarrow \beta \alpha \gamma$

```lean
-- Derivation relation
def derive (grammar : Grammar) (left : String) (right : String) : Bool :=
  ∃ (production : String × String),
  production ∈ grammar.productions ∧
  left.contains production.1 ∧
  right = left.replace production.1 production.2

-- Multi-step derivation
def derive_star (grammar : Grammar) (left : String) (right : String) : Bool :=
  if left = right then
    true
  else
    ∃ (middle : String),
    derive grammar left middle ∧
    derive_star grammar middle right

-- Language generated by grammar
def grammar_language (grammar : Grammar) : Set String :=
  { word | derive_star grammar grammar.start_symbol word ∧
           word.all (λ c => c.toString ∈ grammar.terminals) }
```

### Grammar Classification

**Chomsky Grammar Classification**:

```lean
-- Grammar type enumeration
inductive GrammarType where
  | Type0 : GrammarType  -- Unrestricted grammar
  | Type1 : GrammarType  -- Context-sensitive grammar
  | Type2 : GrammarType  -- Context-free grammar
  | Type3 : GrammarType  -- Regular grammar
  deriving Repr

-- Grammar type determination
def grammar_type (grammar : Grammar) : GrammarType :=
  if is_regular grammar then
    GrammarType.Type3
  else if is_context_free grammar then
    GrammarType.Type2
  else if is_context_sensitive grammar then
    GrammarType.Type1
  else
    GrammarType.Type0

-- Regular grammar check
def is_regular (grammar : Grammar) : Bool :=
  grammar.productions.all (λ prod =>
    let (left, right) := prod
    left.length = 1 ∧
    (right.length = 1 ∨ right.length = 2) ∧
    (right.length = 1 → right.head ∈ grammar.terminals) ∧
    (right.length = 2 → right.head ∈ grammar.terminals ∧ right.tail.head ∈ grammar.non_terminals))

-- Context-free grammar check
def is_context_free (grammar : Grammar) : Bool :=
  grammar.productions.all (λ prod =>
    let (left, right) := prod
    left.length = 1 ∧ left.head ∈ grammar.non_terminals)
```

## 1.5.2.2 Context-Free Grammars

### CFG Definition

**Definition 1.5.2.3** (CFG): A context-free grammar is a special grammar where all production left sides are single non-terminals.

```lean
-- Context-free grammar
structure CFG where
  non_terminals : Set String
  terminals : Set String
  productions : List (String × String)
  start_symbol : String
  deriving Repr

-- CFG validation
def is_valid_cfg (cfg : CFG) : Bool :=
  cfg.start_symbol ∈ cfg.non_terminals ∧
  cfg.productions.all (λ prod =>
    let (left, right) := prod
    left.length = 1 ∧ left.head ∈ cfg.non_terminals)

-- Example: expression grammar
def expression_cfg : CFG := {
  non_terminals := {"Expr", "Term", "Factor"},
  terminals := {"+", "-", "*", "/", "(", ")", "number", "id"},
  productions := [
    ("Expr", "Expr + Term"),
    ("Expr", "Expr - Term"),
    ("Expr", "Term"),
    ("Term", "Term * Factor"),
    ("Term", "Term / Factor"),
    ("Term", "Factor"),
    ("Factor", "(Expr)"),
    ("Factor", "number"),
    ("Factor", "id")
  ],
  start_symbol := "Expr"
}
```

### Parse Trees

**Definition 1.5.2.4** (Parse Tree): A parse tree is a tree representation of grammar derivation.

```lean
-- Parse tree node
inductive ParseTreeNode where
  | Terminal : String → ParseTreeNode
  | NonTerminal : String → List ParseTreeNode → ParseTreeNode
  deriving Repr

-- Parse tree construction
def build_parse_tree (cfg : CFG) (word : String) : Option ParseTreeNode :=
  -- Use recursive descent or LR parsing to build parse tree
  parse_word cfg word

-- Parse tree traversal
def traverse_tree (tree : ParseTreeNode) : List String :=
  match tree with
  | ParseTreeNode.Terminal s => [s]
  | ParseTreeNode.NonTerminal _ children =>
    children.bind traverse_tree

-- Parse tree validation
def validate_parse_tree (cfg : CFG) (tree : ParseTreeNode) : Bool :=
  let word := traverse_tree tree
  word ∈ grammar_language cfg
```

### Ambiguity

**Definition 1.5.2.5** (Ambiguous Grammar): A grammar G is ambiguous if there exist multiple different parse trees for some sentence.

```lean
-- Ambiguity detection
def is_ambiguous (cfg : CFG) : Bool :=
  ∃ (word : String),
  let parse_trees := all_parse_trees cfg word
  parse_trees.length > 1

-- Ambiguous grammar example: classic if-then-else ambiguity
def ambiguous_if_grammar : CFG := {
  non_terminals := {"S", "E"},
  terminals := {"if", "then", "else", "a"},
  productions := [
    ("S", "if E then S"),
    ("S", "if E then S else S"),
    ("S", "a"),
    ("E", "a")
  ],
  start_symbol := "S"
}

-- Disambiguating: through precedence and associativity
def unambiguous_if_grammar : CFG := {
  non_terminals := {"S", "S'", "E"},
  terminals := {"if", "then", "else", "a"},
  productions := [
    ("S", "if E then S else S"),
    ("S", "S'"),
    ("S'", "if E then S'"),
    ("S'", "a"),
    ("E", "a")
  ],
  start_symbol := "S"
}
```

## 1.5.2.3 Parsing Algorithms

### Recursive Descent Parsing

**Recursive descent parsing** is a top-down parsing method.

```lean
-- Recursive descent parser
structure RecursiveDescentParser (cfg : CFG) where
  input : List String
  position : ℕ
  deriving Repr

-- Match terminal
def match_terminal (parser : RecursiveDescentParser cfg) (token : String) : Option (RecursiveDescentParser cfg) :=
  if parser.position < parser.input.length ∧
     parser.input.get parser.position = token then
    some { parser with position := parser.position + 1 }
  else
    none

-- Parse non-terminal
def parse_non_terminal (parser : RecursiveDescentParser cfg) (non_terminal : String) : Option (RecursiveDescentParser cfg) :=
  let productions := cfg.productions.filter (λ prod => prod.1 = non_terminal)
  try_productions parser productions

-- Try productions
def try_productions (parser : RecursiveDescentParser cfg) (productions : List (String × String)) : Option (RecursiveDescentParser cfg) :=
  match productions with
  | [] => none
  | (left, right) :: rest =>
    match parse_production parser right with
    | some new_parser => some new_parser
    | none => try_productions parser rest

-- Parse production right side
def parse_production (parser : RecursiveDescentParser cfg) (right : String) : Option (RecursiveDescentParser cfg) :=
  let symbols := right.split " "
  parse_symbols parser symbols

-- Parse symbol sequence
def parse_symbols (parser : RecursiveDescentParser cfg) (symbols : List String) : Option (RecursiveDescentParser cfg) :=
  match symbols with
  | [] => some parser
  | symbol :: rest =>
    if symbol ∈ cfg.terminals then
      match match_terminal parser symbol with
      | some new_parser => parse_symbols new_parser rest
      | none => none
    else
      match parse_non_terminal parser symbol with
      | some new_parser => parse_symbols new_parser rest
      | none => none
```

### LL Parsing

**LL parsing** is a deterministic top-down parsing method.

```lean
-- LL(1) parsing table
structure LL1Table where
  table : HashMap (String × String) (List String)
  deriving Repr

-- Build LL(1) parsing table
def build_ll1_table (cfg : CFG) : LL1Table :=
  let first_sets := compute_first_sets cfg
  let follow_sets := compute_follow_sets cfg first_sets
  build_table_from_sets cfg first_sets follow_sets

-- Compute FIRST sets
def compute_first_sets (cfg : CFG) : HashMap String (Set String) :=
  -- Compute FIRST set for each non-terminal
  let initial_sets := cfg.non_terminals.map (λ nt => (nt, Set.empty))
  iterate_until_fixed_point initial_sets (λ sets => update_first_sets cfg sets)

-- Compute FOLLOW sets
def compute_follow_sets (cfg : CFG) (first_sets : HashMap String (Set String)) : HashMap String (Set String) :=
  let initial_sets := cfg.non_terminals.map (λ nt => (nt, Set.empty))
  let start_follow := HashMap.insert initial_sets cfg.start_symbol (Set.singleton "$")
  iterate_until_fixed_point start_follow (λ sets => update_follow_sets cfg first_sets sets)

-- LL(1) parser
def ll1_parse (cfg : CFG) (input : List String) : Bool :=
  let table := build_ll1_table cfg
  let stack := [cfg.start_symbol]
  let input_with_eof := input ++ ["$"]
  ll1_parse_step table stack input_with_eof

-- LL(1) parsing step
def ll1_parse_step (table : LL1Table) (stack : List String) (input : List String) : Bool :=
  match stack, input with
  | [], [] => true
  | [], _ => false
  | top :: rest_stack, current :: rest_input =>
    if top ∈ terminals then
      if top = current then
        ll1_parse_step table rest_stack rest_input
      else
        false
    else
      let key := (top, current)
      match table.table.find key with
      | some production => ll1_parse_step table (production ++ rest_stack) input
      | none => false
  | _, _ => false
```

### LR Parsing

**LR parsing** is a bottom-up parsing method.

```lean
-- LR item
structure LRItem where
  production : String × String
  dot_position : ℕ
  lookahead : String
  deriving Repr

-- LR state
structure LRState where
  items : Set LRItem
  deriving Repr

-- LR parsing table
structure LRTable where
  action_table : HashMap (ℕ × String) (String × ℕ)  -- (state, symbol) → (action, target)
  goto_table : HashMap (ℕ × String) ℕ  -- (state, non-terminal) → target state
  deriving Repr

-- Build LR(0) parsing table
def build_lr0_table (cfg : CFG) : LRTable :=
  let initial_state := create_initial_state cfg
  let all_states := compute_lr0_states cfg initial_state
  build_tables_from_states cfg all_states

-- Create initial state
def create_initial_state (cfg : CFG) : LRState := {
  items := Set.singleton {
    production := (cfg.start_symbol, cfg.productions.head.2),
    dot_position := 0,
    lookahead := "$"
  }
}

-- Compute LR(0) states
def compute_lr0_states (cfg : CFG) (initial_state : LRState) : List LRState :=
  let states := [initial_state]
  let transitions := compute_transitions cfg states
  add_states_from_transitions cfg states transitions

-- LR parser
def lr_parse (cfg : CFG) (input : List String) : Bool :=
  let table := build_lr0_table cfg
  let stack := [(0, [])]  -- (state, symbol stack)
  let input_with_eof := input ++ ["$"]
  lr_parse_step table stack input_with_eof

-- LR parsing step
def lr_parse_step (table : LRTable) (stack : List (ℕ × String)) (input : List String) : Bool :=
  match stack, input with
  | [], [] => true
  | (state, symbols) :: rest_stack, current :: rest_input =>
    let key := (state, current)
    match table.action_table.find key with
    | some ("shift", next_state) =>
      lr_parse_step table ((next_state, current :: symbols) :: rest_stack) rest_input
    | some ("reduce", production_index) =>
      let production := get_production production_index
      let new_symbols := reduce_symbols symbols production
      let goto_key := (state, production.1)
      match table.goto_table.find goto_key with
      | some goto_state =>
        lr_parse_step table ((goto_state, production.1 :: new_symbols) :: rest_stack) input
      | none => false
    | some ("accept", _) => true
    | none => false
  | _, _ => false
```

## 1.5.2.4 Practical Application Cases

### Case 1: Programming Language Syntax

**Problem Description**: Design a syntax analyzer for programming languages.

**Grammar Solution**:

```lean
-- Simple programming language grammar
def simple_language_cfg : CFG := {
  non_terminals := {"Program", "Statement", "Expression", "Term", "Factor", "Type"},
  terminals := {"int", "float", "if", "else", "while", "for", "=", "+", "-", "*", "/", "(", ")", "{", "}", ";", "id", "number"},
  productions := [
    -- Program structure
    ("Program", "Statement"),
    ("Program", "Program Statement"),
    
    -- Statements
    ("Statement", "Type id = Expression ;"),
    ("Statement", "if ( Expression ) { Program }"),
    ("Statement", "if ( Expression ) { Program } else { Program }"),
    ("Statement", "while ( Expression ) { Program }"),
    ("Statement", "for ( Statement Expression ; Expression ) { Program }"),
    
    -- Expressions
    ("Expression", "Expression + Term"),
    ("Expression", "Expression - Term"),
    ("Expression", "Term"),
    ("Term", "Term * Factor"),
    ("Term", "Term / Factor"),
    ("Term", "Factor"),
    ("Factor", "( Expression )"),
    ("Factor", "id"),
    ("Factor", "number"),
    
    -- Types
    ("Type", "int"),
    ("Type", "float")
  ],
  start_symbol := "Program"
}

-- Syntax analyzer
def parse_program (source_code : String) : Option ParseTreeNode :=
  let tokens := tokenize source_code
  let cfg := simple_language_cfg
  parse_with_grammar cfg tokens

-- Code generation
def generate_code (parse_tree : ParseTreeNode) : String :=
  match parse_tree with
  | ParseTreeNode.NonTerminal "Program" children =>
    children.map generate_code |> String.join
  | ParseTreeNode.NonTerminal "Statement" children =>
    generate_statement children
  | ParseTreeNode.NonTerminal "Expression" children =>
    generate_expression children
  | _ => ""
```

### Case 2: Natural Language Processing

**Problem Description**: Build a natural language syntactic parser.

**Grammar Solution**:

```lean
-- Natural language grammar
def natural_language_cfg : CFG := {
  non_terminals := {"S", "NP", "VP", "PP", "Det", "Adj", "N", "V", "P"},
  terminals := {"the", "a", "cat", "dog", "big", "small", "runs", "sleeps", "on", "in", "table", "house"},
  productions := [
    -- Sentence structure
    ("S", "NP VP"),
    ("S", "S PP"),
    
    -- Noun phrases
    ("NP", "Det N"),
    ("NP", "Det Adj N"),
    ("NP", "NP PP"),
    
    -- Verb phrases
    ("VP", "V"),
    ("VP", "V NP"),
    ("VP", "V PP"),
    
    -- Prepositional phrases
    ("PP", "P NP"),
    
    -- Parts of speech
    ("Det", "the"),
    ("Det", "a"),
    ("Adj", "big"),
    ("Adj", "small"),
    ("N", "cat"),
    ("N", "dog"),
    ("N", "table"),
    ("N", "house"),
    ("V", "runs"),
    ("V", "sleeps"),
    ("P", "on"),
    ("P", "in")
  ],
  start_symbol := "S"
}

-- Syntactic parsing
def parse_sentence (sentence : String) : Option ParseTreeNode :=
  let words := sentence.split " "
  let cfg := natural_language_cfg
  parse_with_grammar cfg words

-- Dependency analysis
def extract_dependencies (parse_tree : ParseTreeNode) : List (String × String × String) :=
  -- Extract dependencies from parse tree
  extract_deps_from_tree parse_tree

-- Semantic role labeling
def semantic_role_labeling (parse_tree : ParseTreeNode) : HashMap String String :=
  -- Perform semantic role labeling based on parse tree
  label_semantic_roles parse_tree
```

### Case 3: Configuration File Parsing

**Problem Description**: Parse structured configuration files.

**Grammar Solution**:

```lean
-- Configuration file grammar
def config_file_cfg : CFG := {
  non_terminals := {"Config", "Section", "KeyValue", "Key", "Value", "List"},
  terminals := {"[", "]", "=", ",", "id", "string", "number", "true", "false"},
  productions := [
    -- Configuration file structure
    ("Config", "Section"),
    ("Config", "Config Section"),
    ("Config", "Config KeyValue"),
    
    -- Section definition
    ("Section", "[ id ]"),
    ("Section", "[ id ] Config"),
    
    -- Key-value pairs
    ("KeyValue", "Key = Value"),
    ("KeyValue", "Key = List"),
    
    -- Keys and values
    ("Key", "id"),
    ("Value", "string"),
    ("Value", "number"),
    ("Value", "true"),
    ("Value", "false"),
    
    -- Lists
    ("List", "Value"),
    ("List", "List , Value")
  ],
  start_symbol := "Config"
}

-- Configuration file parser
def parse_config (config_text : String) : Option ParseTreeNode :=
  let tokens := tokenize_config config_text
  let cfg := config_file_cfg
  parse_with_grammar cfg tokens

-- Configuration validation
def validate_config (parse_tree : ParseTreeNode) : Bool :=
  -- Validate semantic correctness of configuration file
  validate_config_semantics parse_tree

-- Configuration generation
def generate_config (config_data : HashMap String Dynamic) : String :=
  -- Generate configuration file from data structure
  generate_config_text config_data
```

## 1.5.2.5 References

### Classical Literature

1. **Hopcroft, J.E., Motwani, R., & Ullman, J.D.** (2006). "Introduction to Automata Theory, Languages, and Computation". Pearson Education.
2. **Aho, A.V., Lam, M.S., Sethi, R., & Ullman, J.D.** (2006). "Compilers: Principles, Techniques, and Tools". Pearson Education.
3. **Dragon Book**: "Compilers: Principles, Techniques, and Tools" - Classic textbook on compiler design

### Modern Textbooks

1. **Grune, D., & Jacobs, C.J.H.** (2008). "Parsing Techniques: A Practical Guide". Springer.
2. **Scott, M.L.** (2015). "Programming Language Pragmatics". Morgan Kaufmann.

### Online Resources

1. **Stanford CS143**: <https://web.stanford.edu/class/cs143/>
2. **MIT 6.035**: <https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-035-computer-language-engineering-spring-2010/>

### Further Reading

- [Language Hierarchy](1.5.3-language-hierarchy.md)
- [Automata Theory](1.5.1-automata-theory.md)
- [Type Theory and Proof](../1.2-type-theory-and-proof/README.md)
- [Temporal Logic and Control](../1.3-temporal-logic-and-control/README.md)

---

**Navigation**: [Back to Parent](../README.md) | [Next: Language Hierarchy](1.5.3-language-hierarchy.md) | [Chinese Version](../1-形式化理论/1.5-形式语言与自动化理论/1.5.2-形式文法理论.md)

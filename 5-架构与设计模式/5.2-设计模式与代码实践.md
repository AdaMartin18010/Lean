# 5.2 è®¾è®¡æ¨¡å¼ä¸ä»£ç å®è·µ

**ç°ä»£è½¯ä»¶è®¾è®¡æ¨¡å¼çš„å½¢å¼åŒ–åˆ†æä¸å®è·µæŒ‡å—**

---

## ğŸ¯ æ¦‚è§ˆ

è®¾è®¡æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­ç»è¿‡éªŒè¯çš„è§£å†³æ–¹æ¡ˆæ¨¡æ¿ï¼Œæœ¬æ–‡æ¡£æ¢è®¨ç»å…¸ä¸ç°ä»£è®¾è®¡æ¨¡å¼åœ¨å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨ï¼Œç»“åˆå½¢å¼åŒ–æ–¹æ³•æä¾›æ·±åº¦åˆ†æã€‚

---

## ğŸ“š ç»å…¸è®¾è®¡æ¨¡å¼é‡è®¿

### ğŸ—ï¸ åˆ›å»ºå‹æ¨¡å¼

#### å•ä¾‹æ¨¡å¼ (Singleton)

```rust
use std::sync::{Arc, Mutex, Once};

pub struct Singleton {
    data: String,
}

impl Singleton {
    fn new() -> Self {
        Singleton {
            data: "Singleton Instance".to_string(),
        }
    }
    
    pub fn instance() -> Arc<Mutex<Singleton>> {
        static mut SINGLETON: Option<Arc<Mutex<Singleton>>> = None;
        static ONCE: Once = Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                SINGLETON = Some(Arc::new(Mutex::new(Singleton::new())));
            });
            SINGLETON.clone().unwrap()
        }
    }
}
```

#### å·¥å‚æ¨¡å¼ (Factory)

```lean
-- Leanä¸­çš„æŠ½è±¡å·¥å‚æ¨¡å¼
structure Product (Î± : Type) where
  create : Î±
  validate : Î± â†’ Bool

class ProductFactory (Î± Î² : Type) where
  createProduct : Î± â†’ Product Î²
  
-- å…·ä½“å®ç°
instance : ProductFactory String Nat where
  createProduct s := {
    create := s.length,
    validate := fun n => n > 0
  }
```

### ğŸ”— ç»“æ„å‹æ¨¡å¼

#### é€‚é…å™¨æ¨¡å¼ (Adapter)

```haskell
-- Haskellä¸­çš„é€‚é…å™¨æ¨¡å¼
class Adaptee a where
  specificRequest :: a -> String

class Target a where
  request :: a -> String

-- é€‚é…å™¨å®ç°
newtype Adapter a = Adapter a

instance Adaptee a => Target (Adapter a) where
  request (Adapter a) = "Adapted: " ++ specificRequest a
```

#### è£…é¥°å™¨æ¨¡å¼ (Decorator)

```python
from abc import ABC, abstractmethod
from typing import Protocol

class Component(Protocol):
    def operation(self) -> str: ...

class ConcreteComponent:
    def operation(self) -> str:
        return "ConcreteComponent"

class Decorator:
    def __init__(self, component: Component):
        self._component = component
    
    def operation(self) -> str:
        return self._component.operation()

class ConcreteDecorator(Decorator):
    def operation(self) -> str:
        return f"ConcreteDecorator({super().operation()})"
```

### ğŸ­ è¡Œä¸ºå‹æ¨¡å¼

#### è§‚å¯Ÿè€…æ¨¡å¼ (Observer)

```rust
use std::rc::Rc;
use std::cell::RefCell;

trait Observer {
    fn update(&self, data: &str);
}

struct Subject {
    observers: Vec<Rc<dyn Observer>>,
    state: String,
}

impl Subject {
    fn new() -> Self {
        Subject {
            observers: Vec::new(),
            state: String::new(),
        }
    }
    
    fn attach(&mut self, observer: Rc<dyn Observer>) {
        self.observers.push(observer);
    }
    
    fn notify(&self) {
        for observer in &self.observers {
            observer.update(&self.state);
        }
    }
    
    fn set_state(&mut self, state: String) {
        self.state = state;
        self.notify();
    }
}
```

---

## ğŸš€ ç°ä»£è®¾è®¡æ¨¡å¼

### âš¡ å“åº”å¼ç¼–ç¨‹æ¨¡å¼

#### ååº”å¼æµ (Reactive Streams)

```rust
use futures::stream::{Stream, StreamExt};
use tokio::sync::mpsc;

pub struct ReactiveStream<T> {
    receiver: mpsc::UnboundedReceiver<T>,
}

impl<T> ReactiveStream<T> {
    pub fn new() -> (Self, mpsc::UnboundedSender<T>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        (ReactiveStream { receiver }, sender)
    }
    
    pub async fn map<U, F>(mut self, f: F) -> ReactiveStream<U>
    where
        F: Fn(T) -> U + Send + 'static,
        T: Send + 'static,
        U: Send + 'static,
    {
        let (new_stream, sender) = ReactiveStream::new();
        
        tokio::spawn(async move {
            while let Some(item) = self.receiver.recv().await {
                let _ = sender.send(f(item));
            }
        });
        
        new_stream
    }
}
```

### ğŸŒ å¾®æœåŠ¡æ¨¡å¼

#### æ–­è·¯å™¨æ¨¡å¼ (Circuit Breaker)

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_count: Arc<Mutex<u32>>,
    failure_threshold: u32,
    timeout: Duration,
    last_failure_time: Arc<Mutex<Option<Instant>>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, timeout: Duration) -> Self {
        CircuitBreaker {
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: Arc::new(Mutex::new(0)),
            failure_threshold,
            timeout,
            last_failure_time: Arc::new(Mutex::new(None)),
        }
    }
    
    pub async fn call<F, T, E>(&self, f: F) -> Result<T, E>
    where
        F: std::future::Future<Output = Result<T, E>>,
    {
        if self.is_open() {
            return Err(self.circuit_open_error());
        }
        
        match f.await {
            Ok(result) => {
                self.on_success();
                Ok(result)
            }
            Err(err) => {
                self.on_failure();
                Err(err)
            }
        }
    }
    
    fn is_open(&self) -> bool {
        let state = self.state.lock().unwrap();
        matches!(*state, CircuitState::Open)
    }
    
    fn on_success(&self) {
        let mut failure_count = self.failure_count.lock().unwrap();
        *failure_count = 0;
        
        let mut state = self.state.lock().unwrap();
        *state = CircuitState::Closed;
    }
    
    fn on_failure(&self) {
        let mut failure_count = self.failure_count.lock().unwrap();
        *failure_count += 1;
        
        if *failure_count >= self.failure_threshold {
            let mut state = self.state.lock().unwrap();
            *state = CircuitState::Open;
            
            let mut last_failure = self.last_failure_time.lock().unwrap();
            *last_failure = Some(Instant::now());
        }
    }
}
```

---

## ğŸ”„ å‡½æ•°å¼è®¾è®¡æ¨¡å¼

### ğŸ“¦ å•å­æ¨¡å¼ (Monad Pattern)

```haskell
-- Maybeå•å­å®ç°
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)

instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    Just f <*> x = fmap f x

instance Monad Maybe where
    return = pure
    Nothing >>= _ = Nothing
    Just x >>= f = f x

-- ä½¿ç”¨ç¤ºä¾‹
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

computation :: Double -> Double -> Double -> Maybe Double
computation x y z = do
    result1 <- safeDivide x y
    result2 <- safeDivide result1 z
    return result2
```

### ğŸ”§ ç»„åˆå™¨æ¨¡å¼ (Combinator Pattern)

```lean
-- Leanä¸­çš„è§£æå™¨ç»„åˆå™¨
structure Parser (Î± : Type) where
  parse : String â†’ Option (Î± Ã— String)

def pure {Î± : Type} (a : Î±) : Parser Î± :=
  { parse := fun s => some (a, s) }

def bind {Î± Î² : Type} (p : Parser Î±) (f : Î± â†’ Parser Î²) : Parser Î² :=
  { parse := fun s => 
      match p.parse s with
      | none => none
      | some (a, s') => (f a).parse s' }

def alt {Î± : Type} (p1 p2 : Parser Î±) : Parser Î± :=
  { parse := fun s =>
      match p1.parse s with
      | some result => some result
      | none => p2.parse s }
```

---

## ğŸ—ï¸ æ¶æ„æ¨¡å¼

### ğŸ¯ å…­è¾¹å½¢æ¶æ„ (Hexagonal Architecture)

```rust
// é¢†åŸŸå±‚
pub trait UserRepository {
    async fn find_by_id(&self, id: UserId) -> Option<User>;
    async fn save(&self, user: User) -> Result<(), Error>;
}

// åº”ç”¨æœåŠ¡å±‚
pub struct UserService<R: UserRepository> {
    repository: R,
}

impl<R: UserRepository> UserService<R> {
    pub fn new(repository: R) -> Self {
        UserService { repository }
    }
    
    pub async fn get_user(&self, id: UserId) -> Result<User, Error> {
        self.repository
            .find_by_id(id)
            .await
            .ok_or(Error::UserNotFound)
    }
}

// åŸºç¡€è®¾æ–½å±‚
pub struct PostgresUserRepository {
    pool: sqlx::PgPool,
}

#[async_trait::async_trait]
impl UserRepository for PostgresUserRepository {
    async fn find_by_id(&self, id: UserId) -> Option<User> {
        // æ•°æ®åº“å®ç°
        todo!()
    }
    
    async fn save(&self, user: User) -> Result<(), Error> {
        // æ•°æ®åº“å®ç°
        todo!()
    }
}
```

### ğŸŒŠ äº‹ä»¶é©±åŠ¨æ¶æ„ (Event-Driven Architecture)

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
import asyncio

class Event(ABC):
    @property
    @abstractmethod
    def event_type(self) -> str:
        pass

class EventHandler(ABC):
    @abstractmethod
    async def handle(self, event: Event) -> None:
        pass

class EventBus:
    def __init__(self):
        self._handlers: Dict[str, List[EventHandler]] = {}
    
    def subscribe(self, event_type: str, handler: EventHandler):
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
    
    async def publish(self, event: Event):
        handlers = self._handlers.get(event.event_type, [])
        await asyncio.gather(*[
            handler.handle(event) for handler in handlers
        ])

# å…·ä½“äº‹ä»¶
class UserCreatedEvent(Event):
    def __init__(self, user_id: str, email: str):
        self.user_id = user_id
        self.email = email
    
    @property
    def event_type(self) -> str:
        return "user.created"

# äº‹ä»¶å¤„ç†å™¨
class EmailNotificationHandler(EventHandler):
    async def handle(self, event: Event) -> None:
        if isinstance(event, UserCreatedEvent):
            print(f"Sending welcome email to {event.email}")
```

---

## ğŸ§© å¹¶å‘è®¾è®¡æ¨¡å¼

### ğŸ”„ Actoræ¨¡å¼

```rust
use tokio::sync::mpsc;
use std::collections::HashMap;

pub struct Message {
    pub content: String,
    pub sender: String,
}

pub struct Actor {
    id: String,
    receiver: mpsc::UnboundedReceiver<Message>,
    state: HashMap<String, String>,
}

impl Actor {
    pub fn new(id: String) -> (Self, mpsc::UnboundedSender<Message>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        let actor = Actor {
            id,
            receiver,
            state: HashMap::new(),
        };
        (actor, sender)
    }
    
    pub async fn run(mut self) {
        while let Some(message) = self.receiver.recv().await {
            self.handle_message(message).await;
        }
    }
    
    async fn handle_message(&mut self, message: Message) {
        println!("Actor {} received: {}", self.id, message.content);
        self.state.insert(message.sender, message.content);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
#[tokio::main]
async fn main() {
    let (actor, sender) = Actor::new("actor1".to_string());
    
    tokio::spawn(async move {
        actor.run().await;
    });
    
    sender.send(Message {
        content: "Hello Actor!".to_string(),
        sender: "main".to_string(),
    }).unwrap();
}
```

### ğŸ” è½¯ä»¶äº‹åŠ¡å†…å­˜ (STM)

```haskell
import Control.Concurrent.STM

data Account = Account { balance :: TVar Int }

transfer :: Account -> Account -> Int -> STM ()
transfer from to amount = do
    fromBalance <- readTVar (balance from)
    if fromBalance >= amount
        then do
            writeTVar (balance from) (fromBalance - amount)
            toBalance <- readTVar (balance to)
            writeTVar (balance to) (toBalance + amount)
        else retry

-- ä½¿ç”¨äº‹åŠ¡
main :: IO ()
main = do
    account1 <- Account <$> newTVarIO 1000
    account2 <- Account <$> newTVarIO 500
    
    atomically $ transfer account1 account2 200
    
    balance1 <- readTVarIO (balance account1)
    balance2 <- readTVarIO (balance account2)
    putStrLn $ "Account 1: " ++ show balance1
    putStrLn $ "Account 2: " ++ show balance2
```

---

## ğŸ“Š æ€»ç»“ä¸æœ€ä½³å®è·µ

### ğŸ¯ æ¨¡å¼é€‰æ‹©æŒ‡å—

1. **åˆ›å»ºå‹æ¨¡å¼**: å¯¹è±¡åˆ›å»ºå¤æ‚æ€§ç®¡ç†
2. **ç»“æ„å‹æ¨¡å¼**: å¯¹è±¡ç»„åˆä¸æ¥å£é€‚é…
3. **è¡Œä¸ºå‹æ¨¡å¼**: å¯¹è±¡é—´é€šä¿¡ä¸èŒè´£åˆ†é…
4. **ç°ä»£æ¨¡å¼**: å¾®æœåŠ¡ã€å“åº”å¼ç¼–ç¨‹éœ€æ±‚
5. **å‡½æ•°å¼æ¨¡å¼**: ä¸å¯å˜æ€§ä¸ç»„åˆæ€§

### ğŸš€ å®è·µå»ºè®®

- ğŸ“‹ **éœ€æ±‚é©±åŠ¨**: æ ¹æ®å®é™…é—®é¢˜é€‰æ‹©æ¨¡å¼
- ğŸ”§ **æ¸è¿›å¼é‡‡ç”¨**: ä»ç®€å•æ¨¡å¼å¼€å§‹
- ğŸ“Š **æ€§èƒ½è€ƒé‡**: æƒè¡¡æ¨¡å¼å¤æ‚æ€§ä¸æ€§èƒ½
- ğŸŒ **å›¢é˜Ÿåä½œ**: å»ºç«‹å…±åŒçš„æ¨¡å¼è¯æ±‡
- ğŸ“š **æŒç»­å­¦ä¹ **: è·Ÿè¸ªæ–°å…´æ¨¡å¼è¶‹åŠ¿

---

*æ–‡æ¡£ç‰ˆæœ¬: v1.2*  
*æœ€åæ›´æ–°: 2024å¹´12æœˆ*  
*è´¨é‡ç­‰çº§: é«˜è´¨é‡å®è·µæŒ‡å—*

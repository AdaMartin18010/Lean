# 1.9.2 序列演算 / Sequent Calculus

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.9.1-自然演绎系统.md](1.9.1-自然演绎系统.md)

---

## 1.9.2.1 核心定义 / Core Definition

**中文**：序列演算是一种形式化证明系统，采用序列（sequent）表示推理状态，强调结构规则和归约过程。它由Gerhard Gentzen在1934年提出，为逻辑推理提供了一个系统化的框架。

**English**: Sequent calculus is a formal proof system that uses sequents to represent reasoning states, emphasizing structural rules and reduction processes. It was proposed by Gerhard Gentzen in 1934, providing a systematic framework for logical reasoning.

### 1.9.2.1.1 历史背景 / Historical Background

序列演算由Gerhard Gentzen在1934年提出，作为对自然演绎系统的改进。它引入了序列的概念，将推理状态表示为 $\Gamma \vdash \Delta$ 的形式，其中 $\Gamma$ 是假设集合，$\Delta$ 是结论集合。

### 1.9.2.1.2 核心思想 / Core Ideas

1. **序列结构**：推理状态表示为 $\Gamma \vdash \Delta$
2. **结构规则**：处理假设和结论的结构
3. **逻辑规则**：引入和消解逻辑连接词
4. **归约过程**：通过规则应用逐步简化序列

---

## 1.9.2.2 形式化模型 / Formal Model

### 1.9.2.2.1 序列定义 / Sequent Definition

序列的形式为 $\Gamma \vdash \Delta$，其中：

- $\Gamma$ 是假设集合（左侧）
- $\Delta$ 是结论集合（右侧）
- $\vdash$ 表示推导关系

### 1.9.2.2.2 结构规则 / Structural Rules

**弱化规则（Weakening）**：
$$\frac{\Gamma \vdash \Delta}{\Gamma, A \vdash \Delta} \text{WL} \quad \frac{\Gamma \vdash \Delta}{\Gamma \vdash \Delta, A} \text{WR}$$

**收缩规则（Contraction）**：
$$\frac{\Gamma, A, A \vdash \Delta}{\Gamma, A \vdash \Delta} \text{CL} \quad \frac{\Gamma \vdash \Delta, A, A}{\Gamma \vdash \Delta, A} \text{CR}$$

**交换规则（Exchange）**：
$$\frac{\Gamma, A, B, \Sigma \vdash \Delta}{\Gamma, B, A, \Sigma \vdash \Delta} \text{EL} \quad \frac{\Gamma \vdash \Delta, A, B, \Pi}{\Gamma \vdash \Delta, B, A, \Pi} \text{ER}$$

### 1.9.2.2.3 逻辑规则 / Logical Rules

**合取规则**：
$$\frac{\Gamma, A, B \vdash \Delta}{\Gamma, A \land B \vdash \Delta} \land L \quad \frac{\Gamma \vdash \Delta, A \quad \Gamma \vdash \Delta, B}{\Gamma \vdash \Delta, A \land B} \land R$$

**析取规则**：
$$\frac{\Gamma, A \vdash \Delta \quad \Gamma, B \vdash \Delta}{\Gamma, A \lor B \vdash \Delta} \lor L \quad \frac{\Gamma \vdash \Delta, A, B}{\Gamma \vdash \Delta, A \lor B} \lor R$$

**蕴含规则**：
$$\frac{\Gamma \vdash \Delta, A \quad \Gamma, B \vdash \Delta}{\Gamma, A \to B \vdash \Delta} \to L \quad \frac{\Gamma, A \vdash \Delta, B}{\Gamma \vdash \Delta, A \to B} \to R$$

**否定规则**：
$$\frac{\Gamma \vdash \Delta, A}{\Gamma, \neg A \vdash \Delta} \neg L \quad \frac{\Gamma, A \vdash \Delta}{\Gamma \vdash \Delta, \neg A} \neg R$$

---

## 1.9.2.3 Lean 代码示例 / Lean Code Example

### 1.9.2.3.1 序列结构定义 / Sequent Structure Definition

```lean
-- 序列结构
structure Sequent : Type where
  left : List Prop   -- 假设集合 Γ
  right : List Prop  -- 结论集合 Δ

-- 序列关系
def SequentRel : Sequent → Sequent → Prop :=
  λ s1 s2 => -- 定义序列之间的推导关系
  sorry

-- 序列证明
inductive SequentProof : Sequent → Prop
| axiom : ∀ A, SequentProof ⟨[A], [A]⟩
| weakening_left : ∀ s A, SequentProof s → SequentProof ⟨A :: s.left, s.right⟩
| weakening_right : ∀ s A, SequentProof s → SequentProof ⟨s.left, A :: s.right⟩
| contraction_left : ∀ s A, SequentProof ⟨A :: A :: s.left, s.right⟩ → SequentProof ⟨A :: s.left, s.right⟩
| contraction_right : ∀ s A, SequentProof ⟨s.left, A :: A :: s.right⟩ → SequentProof ⟨s.left, A :: s.right⟩
```

### 1.9.2.3.2 逻辑规则实现 / Logical Rules Implementation

```lean
-- 合取规则
def and_left_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨A :: B :: s.left, s.right⟩ → SequentProof ⟨A ∧ B :: s.left, s.right⟩

def and_right_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨s.left, A :: s.right⟩ → SequentProof ⟨s.left, B :: s.right⟩ → 
  SequentProof ⟨s.left, A ∧ B :: s.right⟩

-- 析取规则
def or_left_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨A :: s.left, s.right⟩ → SequentProof ⟨B :: s.left, s.right⟩ → 
  SequentProof ⟨A ∨ B :: s.left, s.right⟩

def or_right_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨s.left, A :: B :: s.right⟩ → SequentProof ⟨s.left, A ∨ B :: s.right⟩

-- 蕴含规则
def imp_left_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨s.left, A :: s.right⟩ → SequentProof ⟨B :: s.left, s.right⟩ → 
  SequentProof ⟨A → B :: s.left, s.right⟩

def imp_right_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨A :: s.left, B :: s.right⟩ → SequentProof ⟨s.left, A → B :: s.right⟩
```

### 1.9.2.3.3 序列演算证明示例 / Sequent Calculus Proof Examples

```lean
-- 证明 A → A
theorem identity_sequent (A : Prop) : SequentProof ⟨[], [A → A]⟩ := by
  apply SequentProof.imp_right_rule
  apply SequentProof.axiom

-- 证明 A ∧ B → B ∧ A
theorem commutativity_sequent (A B : Prop) : SequentProof ⟨[], [A ∧ B → B ∧ A]⟩ := by
  apply SequentProof.imp_right_rule
  apply SequentProof.and_right_rule
  · apply SequentProof.and_left_rule
    apply SequentProof.axiom
  · apply SequentProof.and_left_rule
    apply SequentProof.axiom

-- 证明 (A → B) → (B → C) → (A → C)
theorem transitivity_sequent (A B C : Prop) : 
  SequentProof ⟨[], [(A → B) → (B → C) → (A → C)]⟩ := by
  apply SequentProof.imp_right_rule
  apply SequentProof.imp_right_rule
  apply SequentProof.imp_right_rule
  apply SequentProof.imp_left_rule
  · apply SequentProof.axiom
  · apply SequentProof.imp_left_rule
    · apply SequentProof.axiom
    · apply SequentProof.axiom
```

### 1.9.2.3.4 自动化证明策略 / Automated Proof Strategies

```lean
-- 序列演算的自动化策略
macro "sequent_auto" : tactic => `(tactic|
  repeat (first | 
    apply SequentProof.axiom |
    apply SequentProof.imp_right_rule |
    apply SequentProof.and_right_rule |
    apply SequentProof.or_right_rule |
    apply SequentProof.imp_left_rule |
    apply SequentProof.and_left_rule |
    apply SequentProof.or_left_rule
  )
)

-- 使用自动化策略
theorem example_auto (A B : Prop) : SequentProof ⟨[], [A → A]⟩ := by
  sequent_auto
```

---

## 1.9.2.4 交叉引用 / Cross References

- [1.9-证明论与推理系统.md](1.9-证明论与推理系统.md)

---

## 1.9.2.5 2025 规范对齐 / Alignment with Lean 4 (2025)

- 序列与规则建议以结构定义 + 引理组合表达；自动化仅用于可机械化的步骤。
- 对应 `Γ ⊢ Δ` 的编码可用列表或多集，保持与规则匹配的良好接口。

---

## 1.9.2.6 版本兼容性 / Version Compatibility

- 结构/规则定义在 Lean 3/4 间兼容；tactic 需要按 Lean 4 语法调整。

---

## 1.9.2.7 参考资料 / References

- 逻辑学教材：序列演算章节
- Lean 社区相关示例

# 1.9.2 序列演算 / Sequent Calculus

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.9.1-自然演绎系统.md](1.9.1-自然演绎系统.md)

---

## 1.9.2.1 核心定义 / Core Definition

**中文**：序列演算是一种形式化证明系统，采用序列（sequent）表示推理状态，强调结构规则和归约过程。它由Gerhard Gentzen在1934年提出，为逻辑推理提供了一个系统化的框架。

**English**: Sequent calculus is a formal proof system that uses sequents to represent reasoning states, emphasizing structural rules and reduction processes. It was proposed by Gerhard Gentzen in 1934, providing a systematic framework for logical reasoning.

### 1.9.2.1.1 历史背景 / Historical Background

序列演算由Gerhard Gentzen在1934年提出，作为对自然演绎系统的改进。它引入了序列的概念，将推理状态表示为 $\Gamma \vdash \Delta$ 的形式，其中 $\Gamma$ 是假设集合，$\Delta$ 是结论集合。

### 1.9.2.1.2 核心思想 / Core Ideas

1. **序列结构**：推理状态表示为 $\Gamma \vdash \Delta$
2. **结构规则**：处理假设和结论的结构
3. **逻辑规则**：引入和消解逻辑连接词
4. **归约过程**：通过规则应用逐步简化序列

---

## 1.9.2.2 形式化模型 / Formal Model

### 1.9.2.2.1 序列定义 / Sequent Definition

序列的形式为 $\Gamma \vdash \Delta$，其中：

- $\Gamma$ 是假设集合（左侧）
- $\Delta$ 是结论集合（右侧）
- $\vdash$ 表示推导关系

### 1.9.2.2.2 结构规则 / Structural Rules

**弱化规则（Weakening）**：
$$\frac{\Gamma \vdash \Delta}{\Gamma, A \vdash \Delta} \text{WL} \quad \frac{\Gamma \vdash \Delta}{\Gamma \vdash \Delta, A} \text{WR}$$

**收缩规则（Contraction）**：
$$\frac{\Gamma, A, A \vdash \Delta}{\Gamma, A \vdash \Delta} \text{CL} \quad \frac{\Gamma \vdash \Delta, A, A}{\Gamma \vdash \Delta, A} \text{CR}$$

**交换规则（Exchange）**：
$$\frac{\Gamma, A, B, \Sigma \vdash \Delta}{\Gamma, B, A, \Sigma \vdash \Delta} \text{EL} \quad \frac{\Gamma \vdash \Delta, A, B, \Pi}{\Gamma \vdash \Delta, B, A, \Pi} \text{ER}$$

### 1.9.2.2.3 逻辑规则 / Logical Rules

**合取规则**：
$$\frac{\Gamma, A, B \vdash \Delta}{\Gamma, A \land B \vdash \Delta} \land L \quad \frac{\Gamma \vdash \Delta, A \quad \Gamma \vdash \Delta, B}{\Gamma \vdash \Delta, A \land B} \land R$$

**析取规则**：
$$\frac{\Gamma, A \vdash \Delta \quad \Gamma, B \vdash \Delta}{\Gamma, A \lor B \vdash \Delta} \lor L \quad \frac{\Gamma \vdash \Delta, A, B}{\Gamma \vdash \Delta, A \lor B} \lor R$$

**蕴含规则**：
$$\frac{\Gamma \vdash \Delta, A \quad \Gamma, B \vdash \Delta}{\Gamma, A \to B \vdash \Delta} \to L \quad \frac{\Gamma, A \vdash \Delta, B}{\Gamma \vdash \Delta, A \to B} \to R$$

**否定规则**：
$$\frac{\Gamma \vdash \Delta, A}{\Gamma, \neg A \vdash \Delta} \neg L \quad \frac{\Gamma, A \vdash \Delta}{\Gamma \vdash \Delta, \neg A} \neg R$$

---

## 1.9.2.3 Lean 代码示例 / Lean Code Example

### 1.9.2.3.1 序列结构定义 / Sequent Structure Definition

```lean
-- 序列结构
structure Sequent : Type where
  left : List Prop   -- 假设集合 Γ
  right : List Prop  -- 结论集合 Δ

-- 序列关系
def SequentRel : Sequent → Sequent → Prop :=
  λ s1 s2 => -- 定义序列之间的推导关系
  sorry

-- 序列证明
inductive SequentProof : Sequent → Prop
| axiom : ∀ A, SequentProof ⟨[A], [A]⟩
| weakening_left : ∀ s A, SequentProof s → SequentProof ⟨A :: s.left, s.right⟩
| weakening_right : ∀ s A, SequentProof s → SequentProof ⟨s.left, A :: s.right⟩
| contraction_left : ∀ s A, SequentProof ⟨A :: A :: s.left, s.right⟩ → SequentProof ⟨A :: s.left, s.right⟩
| contraction_right : ∀ s A, SequentProof ⟨s.left, A :: A :: s.right⟩ → SequentProof ⟨s.left, A :: s.right⟩
```

### 1.9.2.3.2 逻辑规则实现 / Logical Rules Implementation

```lean
-- 合取规则
def and_left_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨A :: B :: s.left, s.right⟩ → SequentProof ⟨A ∧ B :: s.left, s.right⟩

def and_right_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨s.left, A :: s.right⟩ → SequentProof ⟨s.left, B :: s.right⟩ → 
  SequentProof ⟨s.left, A ∧ B :: s.right⟩

-- 析取规则
def or_left_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨A :: s.left, s.right⟩ → SequentProof ⟨B :: s.left, s.right⟩ → 
  SequentProof ⟨A ∨ B :: s.left, s.right⟩

def or_right_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨s.left, A :: B :: s.right⟩ → SequentProof ⟨s.left, A ∨ B :: s.right⟩

-- 蕴含规则
def imp_left_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨s.left, A :: s.right⟩ → SequentProof ⟨B :: s.left, s.right⟩ → 
  SequentProof ⟨A → B :: s.left, s.right⟩

def imp_right_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨A :: s.left, B :: s.right⟩ → SequentProof ⟨s.left, A → B :: s.right⟩

-- 否定规则
def not_left_rule (s : Sequent) (A : Prop) : Prop :=
  SequentProof ⟨s.left, A :: s.right⟩ → SequentProof ⟨¬A :: s.left, s.right⟩

def not_right_rule (s : Sequent) (A : Prop) : Prop :=
  SequentProof ⟨A :: s.left, s.right⟩ → SequentProof ⟨s.left, ¬A :: s.right⟩
  SequentProof ⟨A ∨ B :: s.left, s.right⟩

def or_right_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨s.left, A :: B :: s.right⟩ → SequentProof ⟨s.left, A ∨ B :: s.right⟩

-- 蕴含规则
def imp_left_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨s.left, A :: s.right⟩ → SequentProof ⟨B :: s.left, s.right⟩ → 
  SequentProof ⟨A → B :: s.left, s.right⟩

def imp_right_rule (s : Sequent) (A B : Prop) : Prop :=
  SequentProof ⟨A :: s.left, B :: s.right⟩ → SequentProof ⟨s.left, A → B :: s.right⟩
```

### 1.9.2.3.3 序列演算证明示例 / Sequent Calculus Proof Examples

```lean
-- 证明 A → A
theorem identity_sequent (A : Prop) : SequentProof ⟨[], [A → A]⟩ := by
  apply SequentProof.imp_right_rule
  apply SequentProof.axiom

-- 证明 A ∧ B → B ∧ A
theorem commutativity_sequent (A B : Prop) : SequentProof ⟨[], [A ∧ B → B ∧ A]⟩ := by
  apply SequentProof.imp_right_rule
  apply SequentProof.and_right_rule
  · apply SequentProof.and_left_rule
    apply SequentProof.axiom
  · apply SequentProof.and_left_rule
    apply SequentProof.axiom

-- 证明 (A → B) → (B → C) → (A → C)
theorem transitivity_sequent (A B C : Prop) : 
  SequentProof ⟨[], [(A → B) → (B → C) → (A → C)]⟩ := by
  apply SequentProof.imp_right_rule
  apply SequentProof.imp_right_rule
  apply SequentProof.imp_right_rule
  apply SequentProof.imp_left_rule
  · apply SequentProof.axiom
  · apply SequentProof.imp_left_rule
    · apply SequentProof.axiom
    · apply SequentProof.axiom
```

### 1.9.2.3.4 自动化证明策略 / Automated Proof Strategies

```lean
-- 序列演算的自动化策略
macro "sequent_auto" : tactic => `(tactic|
  repeat (first | 
    apply SequentProof.axiom |
    apply SequentProof.imp_right_rule |
    apply SequentProof.and_right_rule |
    apply SequentProof.or_right_rule |
    apply SequentProof.imp_left_rule |
    apply SequentProof.and_left_rule |
    apply SequentProof.or_left_rule
  )
)

-- 使用自动化策略
theorem example_auto (A B : Prop) : SequentProof ⟨[], [A → A]⟩ := by
  sequent_auto
```

---

## 1.9.2.4 理论意义与应用 / Theoretical Significance and Applications

### 1.9.2.4.1 逻辑基础 / Logical Foundations

序列演算为逻辑推理提供了理论基础：

- **证明理论**：为逻辑推理提供形式化基础
- **证明构造**：指导如何构造逻辑证明
- **推理规则**：提供标准化的推理规则
- **证明验证**：支持证明的自动化验证

### 1.9.2.4.2 计算机科学应用 / Computer Science Applications

- **定理证明器**：Lean、Coq等定理证明器的基础
- **程序验证**：程序正确性证明的理论基础
- **类型系统**：类型理论的形式化基础
- **人工智能**：自动推理系统的理论基础

### 1.9.2.4.3 数学应用 / Mathematical Applications

- **数学证明**：数学定理的形式化证明
- **逻辑研究**：逻辑学的基础研究
- **哲学应用**：哲学逻辑的形式化
- **教育推广**：逻辑学教学的标准方法

## 1.9.2.5 交叉引用 / Cross References

- [1.9-证明论与推理系统.md](1.9-证明论与推理系统.md) - 证明论基础
- [1.9.1-自然演绎系统.md](1.9.1-自然演绎系统.md) - 自然演绎系统
- [1.9.3-归纳证明与递归原理.md](1.9.3-归纳证明与递归原理.md) - 归纳证明方法

---

## 1.9.2.6 2025 规范对齐 / Alignment with Lean 4 (2025)

### 1.9.2.6.1 结构定义 / Structural Definition

- **结构定义**：序列与规则建议以结构定义 + 引理组合表达
- **自动化使用**：自动化仅用于可机械化的步骤
- **编码方式**：对应 `Γ ⊢ Δ` 的编码可用列表或多集

### 1.9.2.6.2 最佳实践 / Best Practices

- **良好接口**：保持与规则匹配的良好接口
- **清晰定义**：序列结构应该清晰明确
- **类型安全**：保证类型安全性和一致性
- **可读性**：提高代码的可读性

### 1.9.2.6.3 扩展开发 / Extension Development

- **模块化设计**：序列演算规则应该模块化设计
- **可扩展性**：支持序列演算规则的扩展
- **测试验证**：充分的测试和验证
- **文档说明**：详细的文档说明

---

## 1.9.2.7 版本兼容性 / Version Compatibility

### 1.9.2.7.1 Lean版本支持 / Lean Version Support

- **Lean 3/4兼容**：结构/规则定义在 Lean 3/4 间兼容
- **语法调整**：tactic 需要按 Lean 4 语法调整
- **功能扩展**：Lean 4 提供了更多的功能扩展

### 1.9.2.7.2 兼容性考虑 / Compatibility Considerations

- **向后兼容**：保证向后兼容性
- **功能测试**：充分测试功能兼容性
- **文档更新**：及时更新相关文档

## 1.9.2.8 参考资料 / References

### 1.9.2.8.1 经典文献 / Classic Literature

- **Gentzen论文**：序列演算的原始提出
- **逻辑学教材**：序列演算章节的详细讨论
- **证明论教材**：证明论基础理论

### 1.9.2.8.2 现代资源 / Modern Resources

- **Lean社区相关示例**：序列演算的实现示例
- **在线教程**：序列演算的学习资源
- **开源项目**：相关的开源实现

### 1.9.2.8.3 进一步阅读 / Further Reading

- **自然演绎**：与序列演算的关系
- **直觉逻辑**：构造性逻辑的发展
- **模态逻辑**：扩展逻辑系统

---

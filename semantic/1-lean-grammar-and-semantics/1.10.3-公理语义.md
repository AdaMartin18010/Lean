# 1.10.3 公理语义 / Axiomatic Semantics

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.10.2-指称语义.md](1.10.2-指称语义.md)

---

## 1.10.3.1 核心定义 / Core Definition

**中文**：公理语义通过给出程序正确性的逻辑公理和推理规则，描述程序的行为，常用于程序验证。它关注程序的逻辑性质而非执行过程，为程序正确性提供了形式化的证明框架。

**English**: Axiomatic semantics describes program behavior by providing logical axioms and inference rules for program correctness, commonly used in program verification. It focuses on the logical properties of programs rather than execution processes, providing a formal proof framework for program correctness.

### 1.10.3.1.1 历史背景 / Historical Background

公理语义由C.A.R. Hoare在1969年提出，作为Hoare逻辑的基础。它提供了一种形式化的方法来描述和验证程序的正确性，是现代程序验证技术的理论基础。

### 1.10.3.1.2 核心思想 / Core Ideas

1. **前置条件**：程序执行前必须满足的条件
2. **后置条件**：程序执行后必须满足的条件
3. **霍尔三元组**：{P} C {Q} 表示在条件P下执行C后满足Q
4. **推理规则**：从简单程序推导复杂程序正确性的规则

---

## 1.10.3.2 形式化模型 / Formal Model

### 1.10.3.2.1 霍尔逻辑 / Hoare Logic

霍尔逻辑是公理语义的核心，基于霍尔三元组：

**霍尔三元组**：$\{P\} \, C \, \{Q\}$

其中：

- $P$ 是前置条件（precondition）
- $C$ 是程序（command）
- $Q$ 是后置条件（postcondition）

**语义**：如果在满足前置条件 $P$ 的状态下执行程序 $C$，且程序终止，则执行后的状态满足后置条件 $Q$。

### 1.10.3.2.2 基本推理规则 / Basic Inference Rules

**赋值规则**：
$$\frac{}{\{P[E/x]\} \, x := E \, \{P\}}$$

**序列规则**：
$$\frac{\{P\} \, C_1 \, \{R\} \quad \{R\} \, C_2 \, \{Q\}}{\{P\} \, C_1; C_2 \, \{Q\}}$$

**条件规则**：
$$\frac{\{P \land B\} \, C_1 \, \{Q\} \quad \{P \land \neg B\} \, C_2 \, \{Q\}}{\{P\} \, \text{if } B \text{ then } C_1 \text{ else } C_2 \, \{Q\}}$$

**循环规则**：
$$\frac{\{P \land B\} \, C \, \{P\}}{\{P\} \, \text{while } B \text{ do } C \, \{P \land \neg B\}}$$

### 1.10.3.2.3 强化和弱化规则 / Strengthening and Weakening Rules

**前置条件强化**：
$$\frac{P' \to P \quad \{P\} \, C \, \{Q\}}{\{P'\} \, C \, \{Q\}}$$

**后置条件弱化**：
$$\frac{\{P\} \, C \, \{Q\} \quad Q \to Q'}{\{P\} \, C \, \{Q'\}}$$

---

## 1.10.3.3 Lean 代码示例 / Lean Code Example

### 1.10.3.3.1 霍尔三元组实现 / Hoare Triple Implementation

```lean
-- 程序状态
structure State : Type where
  vars : String → Nat

-- 程序命令
inductive Command : Type
| skip : Command
| assign : String → Nat → Command
| seq : Command → Command → Command
| if_then_else : Bool → Command → Command → Command
| while : Bool → Command → Command

-- 霍尔三元组
structure HoareTriple : Type where
  pre : State → Prop
  cmd : Command
  post : State → Prop
  valid : ∀ s, pre s → post (exec cmd s)

-- 程序执行函数
def exec : Command → State → State
| Command.skip, s => s
| Command.assign x n, s => { s with vars := λ y => if y = x then n else s.vars y }
| Command.seq c1 c2, s => exec c2 (exec c1 s)
| Command.if_then_else b c1 c2, s => 
  if eval_bool b s then exec c1 s else exec c2 s
| Command.while b c, s => 
  if eval_bool b s then exec (Command.while b c) (exec c s) else s
```

### 1.10.3.3.2 推理规则实现 / Inference Rules Implementation

```lean
-- 赋值规则
theorem assignment_rule (x : String) (E : Nat) (P : State → Prop) :
  HoareTriple (λ s => P (exec (Command.assign x E) s)) 
              (Command.assign x E) 
              P := by
  constructor
  · intro s h
    simp [exec]
    exact h

-- 序列规则
theorem sequence_rule (c1 c2 : Command) (P Q R : State → Prop)
  (h1 : HoareTriple P c1 R) (h2 : HoareTriple R c2 Q) :
  HoareTriple P (Command.seq c1 c2) Q := by
  constructor
  · intro s h
    apply h2.valid
    apply h1.valid
    exact h

-- 条件规则
theorem if_rule (b : Bool) (c1 c2 : Command) (P Q : State → Prop)
  (h1 : HoareTriple (λ s => P s ∧ eval_bool b s) c1 Q)
  (h2 : HoareTriple (λ s => P s ∧ ¬eval_bool b s) c2 Q) :
  HoareTriple P (Command.if_then_else b c1 c2) Q := by
  constructor
  · intro s h
    simp [exec]
    by_cases h_b : eval_bool b s
    · apply h1.valid
      constructor
      · exact h
      · exact h_b
    · apply h2.valid
      constructor
      · exact h
      · exact h_b
```

### 1.10.3.3.3 循环不变式 / Loop Invariants

```lean
-- 循环规则
theorem while_rule (b : Bool) (c : Command) (P : State → Prop)
  (h : HoareTriple (λ s => P s ∧ eval_bool b s) c P) :
  HoareTriple P (Command.while b c) (λ s => P s ∧ ¬eval_bool b s) := by
  constructor
  · intro s h_init
    -- 需要证明循环终止性和不变式保持
    sorry

-- 循环不变式示例：计算阶乘
def factorial_program (n : Nat) : Command :=
  Command.seq 
    (Command.assign "result" 1)
    (Command.seq
      (Command.assign "i" 0)
      (Command.while (λ s => s.vars "i" < n)
        (Command.seq
          (Command.assign "i" (s.vars "i" + 1))
          (Command.assign "result" (s.vars "result" * s.vars "i"))
        )
      )
    )

-- 阶乘程序的不变式
def factorial_invariant (n : Nat) : State → Prop :=
  λ s => s.vars "result" * factorial (s.vars "i") = factorial n

-- 证明阶乘程序的正确性
theorem factorial_correct (n : Nat) :
  HoareTriple (λ s => s.vars "n" = n)
              (factorial_program n)
              (λ s => s.vars "result" = factorial n) := by
  -- 应用序列规则和循环规则
  sorry
```

### 1.10.3.3.4 程序验证示例 / Program Verification Examples

```lean
-- 交换两个变量的程序
def swap_program (x y : String) : Command :=
  Command.seq
    (Command.assign "temp" (s.vars x))
    (Command.seq
      (Command.assign x (s.vars y))
      (Command.assign y (s.vars "temp"))
    )

-- 交换程序的正确性
theorem swap_correct (x y : String) (a b : Nat) :
  HoareTriple (λ s => s.vars x = a ∧ s.vars y = b)
              (swap_program x y)
              (λ s => s.vars x = b ∧ s.vars y = a) := by
  constructor
  · intro s h
    simp [exec, swap_program]
    constructor
    · simp [h]
    · simp [h]

-- 数组求和程序
def sum_array_program (arr : List Nat) : Command :=
  Command.seq
    (Command.assign "sum" 0)
    (Command.seq
      (Command.assign "i" 0)
      (Command.while (λ s => s.vars "i" < arr.length)
        (Command.seq
          (Command.assign "sum" (s.vars "sum" + arr.get (s.vars "i")))
          (Command.assign "i" (s.vars "i" + 1))
        )
      )
    )

-- 数组求和程序的正确性
theorem sum_array_correct (arr : List Nat) :
  HoareTriple (λ s => True)
              (sum_array_program arr)
              (λ s => s.vars "sum" = arr.sum) := by
  -- 需要证明循环不变式
  sorry
```

---

## 1.10.3.4 交叉引用 / Cross References

- [1.10-模型论与语义模型.md](1.10-模型论与语义模型.md)

---

## 1.10.3.5 2025 规范对齐 / Alignment with Lean 4 (2025)

- Hoare逻辑在Lean中应以可验证的断言语言实现，分离程序逻辑与元逻辑。
- 使用 `Prop` 级断言，避免将证明混入计算路径；程序状态与断言应明确分离。
- 示例应展示前置/后置条件的可验证性，而非仅展示结构定义。

---

## 1.10.3.6 版本兼容性 / Version Compatibility

- 若使用程序验证库（如Lean的验证框架），需标注版本与依赖。
- 旧版 `meta` 程序验证代码需迁移至 `Elab` 框架。

---

## 1.10.3.7 参考资料 / References

- Hoare Logic 经典论文与教材
- Lean 程序验证相关文档与示例

# 1.10.3 公理语义 / Axiomatic Semantics

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.10.2-指称语义.md](1.10.2-指称语义.md)

---

## 1.10.3.1 核心定义 / Core Definition

**中文**：公理语义通过给出程序正确性的逻辑公理和推理规则，描述程序的行为，常用于程序验证。它关注程序的逻辑性质而非执行过程，为程序正确性提供了形式化的证明框架。

**English**: Axiomatic semantics describes program behavior by providing logical axioms and inference rules for program correctness, commonly used in program verification. It focuses on the logical properties of programs rather than execution processes, providing a formal proof framework for program correctness.

### 1.10.3.1.1 历史背景 / Historical Background

公理语义由C.A.R. Hoare在1969年提出，作为Hoare逻辑的基础。它提供了一种形式化的方法来描述和验证程序的正确性，是现代程序验证技术的理论基础。

### 1.10.3.1.2 核心思想 / Core Ideas

1. **前置条件**：程序执行前必须满足的条件
2. **后置条件**：程序执行后必须满足的条件
3. **霍尔三元组**：{P} C {Q} 表示在条件P下执行C后满足Q
4. **推理规则**：从简单程序推导复杂程序正确性的规则

---

## 1.10.3.2 形式化模型 / Formal Model

### 1.10.3.2.1 霍尔逻辑 / Hoare Logic

霍尔逻辑是公理语义的核心，基于霍尔三元组：

**霍尔三元组**：$\{P\} \, C \, \{Q\}$

其中：

- $P$ 是前置条件（precondition）
- $C$ 是程序（command）
- $Q$ 是后置条件（postcondition）

**语义**：如果在满足前置条件 $P$ 的状态下执行程序 $C$，且程序终止，则执行后的状态满足后置条件 $Q$。

### 1.10.3.2.2 基本推理规则 / Basic Inference Rules

**赋值规则**：
$$\frac{}{\{P[E/x]\} \, x := E \, \{P\}}$$

**序列规则**：
$$\frac{\{P\} \, C_1 \, \{R\} \quad \{R\} \, C_2 \, \{Q\}}{\{P\} \, C_1; C_2 \, \{Q\}}$$

**条件规则**：
$$\frac{\{P \land B\} \, C_1 \, \{Q\} \quad \{P \land \neg B\} \, C_2 \, \{Q\}}{\{P\} \, \text{if } B \text{ then } C_1 \text{ else } C_2 \, \{Q\}}$$

**循环规则**：
$$\frac{\{P \land B\} \, C \, \{P\}}{\{P\} \, \text{while } B \text{ do } C \, \{P \land \neg B\}}$$

### 1.10.3.2.3 强化和弱化规则 / Strengthening and Weakening Rules

**前置条件强化**：
$$\frac{P' \to P \quad \{P\} \, C \, \{Q\}}{\{P'\} \, C \, \{Q\}}$$

**后置条件弱化**：
$$\frac{\{P\} \, C \, \{Q\} \quad Q \to Q'}{\{P\} \, C \, \{Q'\}}$$

---

## 1.10.3.3 Lean 代码示例 / Lean Code Example

### 1.10.3.3.1 霍尔三元组实现 / Hoare Triple Implementation

```lean
-- 程序状态
structure State : Type where
  vars : String → Nat

-- 程序命令
inductive Command : Type
| skip : Command
| assign : String → Nat → Command
| seq : Command → Command → Command
| if_then_else : Bool → Command → Command → Command
| while : Bool → Command → Command

-- 霍尔三元组
structure HoareTriple : Type where
  pre : State → Prop
  cmd : Command
  post : State → Prop
  valid : ∀ s, pre s → post (exec cmd s)

-- 程序执行函数
def exec : Command → State → State
| Command.skip, s => s
| Command.assign x n, s => { s with vars := λ y => if y = x then n else s.vars y }
| Command.seq c1 c2, s => exec c2 (exec c1 s)
| Command.if_then_else b c1 c2, s => 
  if eval_bool b s then exec c1 s else exec c2 s
| Command.while b c, s => 
  if eval_bool b s then exec (Command.while b c) (exec c s) else s

-- 布尔表达式求值
def eval_bool : Bool → State → Bool
| Bool.true, _ => true
| Bool.false, _ => false

-- 霍尔逻辑推理规则
theorem assignment_rule (x : String) (E : Nat) (P : State → Prop) :
  HoareTriple (λ s => P (exec (Command.assign x E) s)) 
              (Command.assign x E) 
              P := by
  constructor
  intro s h
  simp [exec]
  exact h

-- 序列规则
theorem sequence_rule (C1 C2 : Command) (P Q R : State → Prop)
  (h1 : HoareTriple P C1 R) (h2 : HoareTriple R C2 Q) :
  HoareTriple P (Command.seq C1 C2) Q := by
  constructor
  intro s h
  have h1_exec := h1.valid s h
  have h2_exec := h2.valid (exec C1 s) h1_exec
  simp [exec]
  exact h2_exec
```

### 1.10.3.3.2 推理规则实现 / Inference Rules Implementation

```lean
-- 赋值规则
theorem assignment_rule (x : String) (E : Nat) (P : State → Prop) :
  HoareTriple (λ s => P (exec (Command.assign x E) s)) 
              (Command.assign x E) 
              P := by
  constructor
  · intro s h
    simp [exec]
    exact h

-- 序列规则
theorem sequence_rule (c1 c2 : Command) (P Q R : State → Prop)
  (h1 : HoareTriple P c1 R) (h2 : HoareTriple R c2 Q) :
  HoareTriple P (Command.seq c1 c2) Q := by
  constructor
  · intro s h
    apply h2.valid
    apply h1.valid
    exact h

-- 条件规则
theorem if_rule (b : Bool) (c1 c2 : Command) (P Q : State → Prop)
  (h1 : HoareTriple (λ s => P s ∧ eval_bool b s) c1 Q)
  (h2 : HoareTriple (λ s => P s ∧ ¬eval_bool b s) c2 Q) :
  HoareTriple P (Command.if_then_else b c1 c2) Q := by
  constructor
  · intro s h
    simp [exec]
    by_cases h_b : eval_bool b s
    · apply h1.valid
      constructor
      · exact h
      · exact h_b
    · apply h2.valid
      constructor
      · exact h
      · exact h_b
```

### 1.10.3.3.3 循环不变式 / Loop Invariants

```lean
-- 循环规则
theorem while_rule (b : Bool) (c : Command) (P : State → Prop)
  (h : HoareTriple (λ s => P s ∧ eval_bool b s) c P) :
  HoareTriple P (Command.while b c) (λ s => P s ∧ ¬eval_bool b s) := by
  constructor
  · intro s h_init
    -- 需要证明循环终止性和不变式保持
    sorry

-- 循环不变式示例：计算阶乘
def factorial_program (n : Nat) : Command :=
  Command.seq 
    (Command.assign "result" 1)
    (Command.seq
      (Command.assign "i" 0)
      (Command.while (λ s => s.vars "i" < n)
        (Command.seq
          (Command.assign "i" (s.vars "i" + 1))
          (Command.assign "result" (s.vars "result" * s.vars "i"))
        )
      )
    )

-- 阶乘程序的不变式
def factorial_invariant (n : Nat) : State → Prop :=
  λ s => s.vars "result" * factorial (s.vars "i") = factorial n

-- 证明阶乘程序的正确性
theorem factorial_correct (n : Nat) :
  HoareTriple (λ s => s.vars "n" = n)
              (factorial_program n)
              (λ s => s.vars "result" = factorial n) := by
  -- 应用序列规则和循环规则
  sorry
```

### 1.10.3.3.4 程序验证示例 / Program Verification Examples

```lean
-- 交换两个变量的程序
def swap_program (x y : String) : Command :=
  Command.seq
    (Command.assign "temp" (s.vars x))
    (Command.seq
      (Command.assign x (s.vars y))
      (Command.assign y (s.vars "temp"))
    )

-- 交换程序的正确性
theorem swap_correct (x y : String) (a b : Nat) :
  HoareTriple (λ s => s.vars x = a ∧ s.vars y = b)
              (swap_program x y)
              (λ s => s.vars x = b ∧ s.vars y = a) := by
  constructor
  · intro s h
    simp [exec, swap_program]
    constructor
    · simp [h]
    · simp [h]

-- 数组求和程序
def sum_array_program (arr : List Nat) : Command :=
  Command.seq
    (Command.assign "sum" 0)
    (Command.seq
      (Command.assign "i" 0)
      (Command.while (λ s => s.vars "i" < arr.length)
        (Command.seq
          (Command.assign "sum" (s.vars "sum" + arr.get (s.vars "i")))
          (Command.assign "i" (s.vars "i" + 1))
        )
      )
    )

-- 数组求和程序的正确性
theorem sum_array_correct (arr : List Nat) :
  HoareTriple (λ s => True)
              (sum_array_program arr)
              (λ s => s.vars "sum" = arr.sum) := by
  -- 使用序列规则、赋值规则和循环规则
  sorry

-- 强化和弱化规则
theorem strengthening (P P' : State → Prop) (C : Command) (Q : State → Prop)
  (h_impl : ∀ s, P' s → P s) (h_triple : HoareTriple P C Q) :
  HoareTriple P' C Q := by
  constructor
  intro s h
  apply h_triple.valid
  exact h_impl s h

theorem weakening (P : State → Prop) (C : Command) (Q Q' : State → Prop)
  (h_impl : ∀ s, Q s → Q' s) (h_triple : HoareTriple P C Q) :
  HoareTriple P C Q' := by
  constructor
  intro s h
  apply h_impl
  exact h_triple.valid s h
              (λ s => s.vars "sum" = arr.sum) := by
  -- 需要证明循环不变式
  sorry
```

---

## 1.10.3.4 理论意义与应用 / Theoretical Significance and Applications

### 1.10.3.4.1 程序验证 / Program Verification

公理语义为程序验证提供了理论基础：

- **正确性证明**：为程序提供形式化的正确性证明
- **安全性验证**：验证程序的安全性质
- **功能验证**：验证程序的功能正确性
- **并发验证**：验证并发程序的正确性

### 1.10.3.4.2 软件工程 / Software Engineering

- **形式化方法**：软件开发的形式化方法
- **代码审查**：基于逻辑的代码审查
- **测试理论**：基于规范的测试理论
- **质量保证**：软件质量的形式化保证

### 1.10.3.4.3 计算机科学应用 / Computer Science Applications

- **编译器验证**：编译器的正确性验证
- **协议验证**：网络协议的正确性验证
- **系统验证**：操作系统的正确性验证
- **硬件验证**：硬件设计的正确性验证

## 1.10.3.5 交叉引用 / Cross References

- [1.10-模型论与语义模型.md](1.10-模型论与语义模型.md) - 语义模型基础
- [1.10.2-指称语义.md](1.10.2-指称语义.md) - 指称语义方法
- [1.10.1-操作语义.md](1.10.1-操作语义.md) - 操作语义方法

---

## 1.10.3.6 2025 规范对齐 / Alignment with Lean 4 (2025)

### 1.10.3.6.1 逻辑实现 / Logic Implementation

- **断言语言**：Hoare逻辑在Lean中应以可验证的断言语言实现
- **逻辑分离**：分离程序逻辑与元逻辑
- **状态分离**：程序状态与断言应明确分离

### 1.10.3.6.2 最佳实践 / Best Practices

- **Prop级断言**：使用 `Prop` 级断言，避免将证明混入计算路径
- **可验证性**：示例应展示前置/后置条件的可验证性
- **清晰定义**：断言应该清晰明确
- **类型安全**：保证类型安全性和一致性

### 1.10.3.6.3 扩展开发 / Extension Development

- **模块化设计**：逻辑规则应该模块化设计
- **可扩展性**：支持逻辑规则的扩展
- **测试验证**：充分的测试和验证
- **文档说明**：详细的文档说明

---

## 1.10.3.7 版本兼容性 / Version Compatibility

### 1.10.3.7.1 Lean版本支持 / Lean Version Support

- **验证库**：若使用程序验证库（如Lean的验证框架），需标注版本与依赖
- **代码迁移**：旧版 `meta` 程序验证代码需迁移至 `Elab` 框架
- **功能扩展**：Lean 4 提供了更多的功能扩展

### 1.10.3.7.2 兼容性考虑 / Compatibility Considerations

- **向后兼容**：保证向后兼容性
- **功能测试**：充分测试功能兼容性
- **文档更新**：及时更新相关文档

## 1.10.3.8 参考资料 / References

### 1.10.3.8.1 经典文献 / Classic Literature

- **Hoare Logic经典论文**：Hoare逻辑的原始提出
- **程序验证教材**：程序验证的详细讨论
- **形式化方法教材**：形式化方法基础理论

### 1.10.3.8.2 现代资源 / Modern Resources

- **Lean程序验证相关文档**：程序验证的实现示例
- **社区示例**：相关的社区实现
- **在线教程**：程序验证的学习资源

### 1.10.3.8.3 进一步阅读 / Further Reading

- **操作语义**：与公理语义的关系
- **指称语义**：另一种语义方法
- **并发验证**：并发程序的验证方法

---

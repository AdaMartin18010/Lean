# 1.11.1 范畴与函子 / Categories and Functors

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.11-范畴论与类型理论.md](1.11-范畴论与类型理论.md)

---

## 1.11.1.1 核心定义 / Core Definition

**中文**：范畴是由对象和态射（箭头）及其组合规则组成的结构，函子是范畴之间保持结构的映射。范畴论为数学提供了一个统一的框架，将各种数学结构抽象为对象和态射的组合。

**English**: A category is a structure consisting of objects and morphisms (arrows) with composition rules; a functor is a structure-preserving mapping between categories. Category theory provides a unified framework for mathematics, abstracting various mathematical structures as combinations of objects and morphisms.

### 1.11.1.1.1 历史背景 / Historical Background

范畴论由Samuel Eilenberg和Saunders Mac Lane在1940年代提出，最初用于代数拓扑学。它提供了一种抽象的方法来研究数学结构之间的关系，现已成为现代数学和计算机科学的重要工具。

### 1.11.1.1.2 核心思想 / Core Ideas

1. **对象和态射**：范畴由对象和它们之间的态射组成
2. **组合律**：态射可以组合，满足结合律
3. **恒等元**：每个对象都有恒等态射
4. **函子**：保持范畴结构的映射

---

## 1.11.1.2 形式化模型 / Formal Model

### 1.11.1.2.1 范畴定义 / Category Definition

范畴 $\mathcal{C}$ 由以下部分组成：

1. **对象集合**：$\text{Ob}(\mathcal{C})$
2. **态射集合**：对于每对对象 $A, B \in \text{Ob}(\mathcal{C})$，有态射集合 $\text{Hom}_{\mathcal{C}}(A, B)$
3. **组合律**：对于 $f : A \to B$ 和 $g : B \to C$，有 $g \circ f : A \to C$
4. **恒等元**：对于每个对象 $A$，有恒等态射 $\text{id}_A : A \to A$

**公理**：

- **结合律**：$(h \circ g) \circ f = h \circ (g \circ f)$
- **恒等律**：$\text{id}_B \circ f = f = f \circ \text{id}_A$

### 1.11.1.2.2 函子定义 / Functor Definition

函子 $F : \mathcal{C} \to \mathcal{D}$ 由以下部分组成：

1. **对象映射**：$F : \text{Ob}(\mathcal{C}) \to \text{Ob}(\mathcal{D})$
2. **态射映射**：对于 $f : A \to B$，有 $F(f) : F(A) \to F(B)$

**公理**：

- **保持组合**：$F(g \circ f) = F(g) \circ F(f)$
- **保持恒等**：$F(\text{id}_A) = \text{id}_{F(A)}$

### 1.11.1.2.3 自然变换 / Natural Transformations

自然变换 $\alpha : F \Rightarrow G$ 是函子之间的映射：

对于每个对象 $A$，有态射 $\alpha_A : F(A) \to G(A)$，满足：
对于每个态射 $f : A \to B$，有 $G(f) \circ \alpha_A = \alpha_B \circ F(f)$

---

## 1.11.1.3 Lean 代码示例 / Lean Code Example

### 1.11.1.3.1 基本范畴定义 / Basic Category Definition

```lean
-- 范畴类型类
class Category (Obj : Type) where
  Hom : Obj → Obj → Type
  id : ∀ X : Obj, Hom X X
  comp : ∀ {X Y Z : Obj}, Hom X Y → Hom Y Z → Hom X Z
  
  -- 公理
  id_left : ∀ {X Y : Obj} (f : Hom X Y), comp (id X) f = f
  id_right : ∀ {X Y : Obj} (f : Hom X Y), comp f (id Y) = f
  assoc : ∀ {W X Y Z : Obj} (f : Hom W X) (g : Hom X Y) (h : Hom Y Z),
    comp (comp f g) h = comp f (comp g h)

-- 集合范畴
instance : Category Type where
  Hom := λ A B => A → B
  id := λ A => λ x => x
  comp := λ f g => λ x => g (f x)
  id_left := by simp
  id_right := by simp
  assoc := by simp
```

### 1.11.1.3.2 函子定义 / Functor Definition

```lean
-- 函子类型类
class Functor {C D : Type} [Category C] [Category D] (F : C → D) where
  map : ∀ {X Y : C}, Category.Hom X Y → Category.Hom (F X) (F Y)
  
  -- 公理
  map_id : ∀ X : C, map (Category.id X) = Category.id (F X)
  map_comp : ∀ {X Y Z : C} (f : Category.Hom X Y) (g : Category.Hom Y Z),
    map (Category.comp f g) = Category.comp (map f) (map g)

-- 恒等函子
def IdFunctor {C : Type} [Category C] : C → C := λ X => X

instance {C : Type} [Category C] : Functor (IdFunctor : C → C) where
  map := λ f => f
  map_id := by simp
  map_comp := by simp

-- 复合函子
def CompFunctor {C D E : Type} [Category C] [Category D] [Category E] 
  (F : C → D) (G : D → E) [Functor F] [Functor G] : C → E := λ X => G (F X)

instance {C D E : Type} [Category C] [Category D] [Category E] 
  (F : C → D) (G : D → E) [Functor F] [Functor G] : Functor (CompFunctor F G) where
  map := λ f => Functor.map (Functor.map f)
  map_id := by simp [Functor.map_id]
  map_comp := by simp [Functor.map_comp]

-- 恒等函子
def IdFunctor {C : Type} [Category C] : C → C := λ X => X

instance {C : Type} [Category C] : Functor (IdFunctor : C → C) where
  map := λ f => f
  map_id := by simp
  map_comp := by simp

-- 复合函子
def CompFunctor {C D E : Type} [Category C] [Category D] [Category E]
  (F : C → D) (G : D → E) [Functor F] [Functor G] : C → E := λ X => G (F X)

instance {C D E : Type} [Category C] [Category D] [Category E]
  (F : C → D) (G : D → E) [Functor F] [Functor G] : Functor (CompFunctor F G) where
  map := λ f => Functor.map (Functor.map f)
  map_id := by simp [Functor.map_id]
  map_comp := by simp [Functor.map_comp]
```

### 1.11.1.3.3 自然变换 / Natural Transformations

```lean
-- 自然变换
structure NaturalTransformation {C D : Type} [Category C] [Category D]
  (F G : C → D) [Functor F] [Functor G] where
  component : ∀ X : C, Category.Hom (F X) (G X)
  naturality : ∀ {X Y : C} (f : Category.Hom X Y),
    Category.comp (Functor.map f) (component Y) = 
    Category.comp (component X) (Functor.map f)

-- 自然变换的复合
def comp_nat_trans {C D : Type} [Category C] [Category D]
  {F G H : C → D} [Functor F] [Functor G] [Functor H]
  (α : NaturalTransformation F G) (β : NaturalTransformation G H) :
  NaturalTransformation F H :=
  { component := λ X => Category.comp (α.component X) (β.component X)
    naturality := by
      intro X Y f
      simp [NaturalTransformation.naturality]
      sorry
  }
```

### 1.11.1.3.4 具体范畴示例 / Concrete Category Examples

```lean
-- 预序范畴
structure Preorder (α : Type) where
  le : α → α → Prop
  refl : ∀ x, le x x
  trans : ∀ x y z, le x y → le y z → le x z

instance {α : Type} [Preorder α] : Category α where
  Hom := λ x y => Preorder.le x y
  id := λ x => Preorder.refl x
  comp := λ h g => Preorder.trans _ _ _ h g
  id_left := by simp
  id_right := by simp
  assoc := by simp

-- 群范畴
structure Group where
  carrier : Type
  mul : carrier → carrier → carrier
  one : carrier
  inv : carrier → carrier
  -- 群公理省略

instance : Category Group where
  Hom := λ G H => GroupHom G H
  id := λ G => GroupHom.id G
  comp := λ f g => GroupHom.comp f g
  -- 公理证明省略
```

---

## 1.11.1.4 理论意义与应用 / Theoretical Significance and Applications

### 1.11.1.4.1 数学基础 / Mathematical Foundations

范畴论为数学提供了统一的框架：

- **抽象代数**：群、环、模等代数结构的统一处理
- **拓扑学**：拓扑空间和连续映射的范畴化
- **几何学**：几何对象和变换的范畴化
- **逻辑学**：逻辑系统和推理规则的范畴化

### 1.11.1.4.2 计算机科学应用 / Computer Science Applications

- **类型理论**：类型和函数的范畴化
- **程序语义**：程序和计算过程的范畴化
- **并发理论**：并发系统和同步的范畴化
- **数据库理论**：数据库和查询的范畴化

### 1.11.1.4.3 跨学科应用 / Interdisciplinary Applications

- **物理学**：量子力学和场论的范畴化
- **生物学**：生物系统和过程的范畴化
- **语言学**：语言结构和语法的范畴化
- **认知科学**：认知过程和思维的范畴化

## 1.11.1.5 交叉引用 / Cross References

- [1.11-范畴论与类型理论.md](1.11-范畴论与类型理论.md) - 范畴论基础
- [1.11.2-自然变换与极限.md](1.11.2-自然变换与极限.md) - 自然变换理论
- [1.11.3-Curry-Howard-Lambek对应.md](1.11.3-Curry-Howard-Lambek对应.md) - 三对应理论

---

## 1.11.1.6 2025 规范对齐 / Alignment with Lean 4 (2025)

### 1.11.1.6.1 范畴实现 / Category Implementation

- **类型类实现**：范畴在Lean中通过类型类 `Category` 实现
- **函子类型类**：函子通过 `Functor` 类型类实现
- **模块导入**：若使用mathlib4的CategoryTheory，需显式 `import Mathlib.CategoryTheory`

### 1.11.1.6.2 最佳实践 / Best Practices

- **对象态射分离**：范畴对象与态射应明确分离，避免混淆类型与值
- **清晰定义**：范畴和函子的定义应该清晰明确
- **类型安全**：保证类型安全性和一致性
- **可读性**：提高代码的可读性

### 1.11.1.6.3 扩展开发 / Extension Development

- **模块化设计**：范畴论结构应该模块化设计
- **可扩展性**：支持范畴论结构的扩展
- **测试验证**：充分的测试和验证
- **文档说明**：详细的文档说明

---

## 1.11.1.7 版本兼容性 / Version Compatibility

### 1.11.1.7.1 Lean版本支持 / Lean Version Support

- **mathlib4依赖**：若依赖mathlib4的CategoryTheory模块，需标注版本兼容性
- **API变化**：范畴论相关API可能随mathlib4版本更新而变化
- **功能扩展**：Lean 4 提供了更多的功能扩展

### 1.11.1.7.2 兼容性考虑 / Compatibility Considerations

- **向后兼容**：保证向后兼容性
- **功能测试**：充分测试功能兼容性
- **文档更新**：及时更新相关文档

## 1.11.1.8 参考资料 / References

### 1.11.1.8.1 经典文献 / Classic Literature

- **Eilenberg-Mac Lane论文**：范畴论的原始提出
- **标准范畴论教材**：范畴论的详细讨论

---

## 本地导航 / Local Navigation

- 上一节：`1.11-范畴论与类型理论.md`
- 下一节：`1.11.2-自然变换与极限.md`
- 返回：`1.11-范畴论与类型理论.md`
- 全局：`INDEX.md` | `CONTENT_STANDARDS.md` | `CONTINUOUS_PROGRESS.md`
- **代数拓扑教材**：范畴论在拓扑学中的应用

### 1.11.1.8.2 现代资源 / Modern Resources

- **Mathlib4 CategoryTheory文档**：范畴论的实现示例
- **社区示例**：相关的社区实现
- **在线教程**：范畴论的学习资源

### 1.11.1.8.3 进一步阅读 / Further Reading

- **自然变换**：函子之间的映射
- **极限理论**：范畴论的核心概念
- **同调代数**：范畴论在代数中的应用

---



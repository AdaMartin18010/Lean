# 1.11.3 Curry-Howard-Lambek 对应 / Curry-Howard-Lambek Correspondence

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.11.2-自然变换与极限.md](1.11.2-自然变换与极限.md)

---

## 1.11.3.1 核心定义 / Core Definition

**中文**：Curry-Howard-Lambek 对应揭示了类型论、逻辑与范畴论三者之间的深刻统一关系。它将三个看似独立的数学领域统一在一个框架下，为数学和计算机科学提供了统一的视角。

**English**: The Curry-Howard-Lambek correspondence reveals the deep unification among type theory, logic, and category theory. It unifies three seemingly independent mathematical fields under a single framework, providing a unified perspective for mathematics and computer science.

### 1.11.3.1.1 历史背景 / Historical Background

Curry-Howard-Lambek对应是三个独立发现的统一：

1. **Curry-Howard对应**：Haskell Curry和William Howard发现类型论与直觉主义逻辑的对应
2. **Lambek对应**：Joachim Lambek发现类型论与范畴论的对应
3. **统一框架**：将三者统一为Curry-Howard-Lambek对应

### 1.11.3.1.2 核心思想 / Core Ideas

1. **类型即命题**：类型系统中的类型对应逻辑中的命题
2. **程序即证明**：类型系统中的程序对应逻辑中的证明
3. **对象即类型**：范畴论中的对象对应类型系统中的类型
4. **态射即程序**：范畴论中的态射对应类型系统中的程序

---

## 1.11.3.2 形式化模型 / Formal Model

### 1.11.3.2.1 三重对应关系 / Triple Correspondence

Curry-Howard-Lambek对应建立了三个领域之间的映射：

| 类型论 | 逻辑 | 范畴论 |
|--------|------|--------|
| 类型 $A$ | 命题 $A$ | 对象 $A$ |
| 程序 $f : A \to B$ | 证明 $A \vdash B$ | 态射 $f : A \to B$ |
| 函数类型 $A \to B$ | 蕴含 $A \Rightarrow B$ | 指数对象 $B^A$ |
| 积类型 $A \times B$ | 合取 $A \land B$ | 直积 $A \times B$ |
| 和类型 $A + B$ | 析取 $A \lor B$ | 直和 $A \oplus B$ |
| 单位类型 $\text{Unit}$ | 真 $\top$ | 终对象 $1$ |
| 空类型 $\text{Void}$ | 假 $\bot$ | 始对象 $0$ |

### 1.11.3.2.2 范畴解释 / Categorical Interpretation

**指数对象**：$B^A$ 满足泛性质：
$$\text{Hom}(C \times A, B) \cong \text{Hom}(C, B^A)$$

**直积**：$A \times B$ 满足泛性质：
$$\text{Hom}(C, A \times B) \cong \text{Hom}(C, A) \times \text{Hom}(C, B)$$

**直和**：$A \oplus B$ 满足泛性质：
$$\text{Hom}(A \oplus B, C) \cong \text{Hom}(A, C) \times \text{Hom}(B, C)$$

### 1.11.3.2.3 逻辑解释 / Logical Interpretation

**蕴含引入**：
$$\frac{\Gamma, A \vdash B}{\Gamma \vdash A \Rightarrow B}$$

**蕴含消解**：
$$\frac{\Gamma \vdash A \Rightarrow B \quad \Gamma \vdash A}{\Gamma \vdash B}$$

**合取引入**：
$$\frac{\Gamma \vdash A \quad \Gamma \vdash B}{\Gamma \vdash A \land B}$$

**析取引入**：
$$\frac{\Gamma \vdash A}{\Gamma \vdash A \lor B} \quad \frac{\Gamma \vdash B}{\Gamma \vdash A \lor B}$$

---

## 1.11.3.3 Lean 代码示例 / Lean Code Example

### 1.11.3.3.1 类型-命题对应 / Type-Proposition Correspondence

```lean
-- 类型即命题
def TypeAsProp (α : Type) : Prop := True

-- 函数类型即蕴含
def FunctionAsImplication {α β : Type} (f : α → β) : α → β := f

-- 积类型即合取
def ProductAsConjunction {α β : Type} (p : α × β) : α ∧ β :=
  ⟨p.1, p.2⟩

-- 和类型即析取
def SumAsDisjunction {α β : Type} (s : α ⊕ β) : α ∨ β :=
  match s with
  | Sum.inl a => Or.inl a
  | Sum.inr b => Or.inr b

-- 单位类型即真
def UnitAsTrue : Unit → True := λ _ => True.intro

-- 空类型即假
def VoidAsFalse : Void → False := λ v => nomatch v
```

### 1.11.3.3.2 程序-证明对应 / Program-Proof Correspondence

```lean
-- 程序即证明
def program_as_proof {α β : Type} (f : α → β) (a : α) : β := f a

-- 恒等函数即恒等证明
def id_proof {α : Type} : α → α := λ x => x

-- 复合函数即复合证明
def compose_proof {α β γ : Type} (f : β → γ) (g : α → β) : α → γ :=
  λ x => f (g x)

-- 交换律的证明
def swap_proof {α β : Type} : α × β → β × α :=
  λ p => (p.2, p.1)

-- 分配律的证明
def distrib_proof {α β γ : Type} : α × (β ⊕ γ) → (α × β) ⊕ (α × γ) :=
  λ p => match p.2 with
  | Sum.inl b => Sum.inl (p.1, b)
  | Sum.inr c => Sum.inr (p.1, c)
```

### 1.11.3.3.3 范畴论解释 / Categorical Interpretation

```lean
-- 指数对象的范畴解释
def exponential_object {α β γ : Type} (f : γ × α → β) : γ → (α → β) :=
  λ c => λ a => f (c, a)

def exponential_uncurry {α β γ : Type} (f : γ → (α → β)) : γ × α → β :=
  λ p => f p.1 p.2

-- 直积的范畴解释
def product_universal {α β γ : Type} (f : γ → α) (g : γ → β) : γ → α × β :=
  λ c => (f c, g c)

def product_projection1 {α β : Type} : α × β → α := λ p => p.1
def product_projection2 {α β : Type} : α × β → β := λ p => p.2

-- 直和的范畴解释
def coproduct_universal {α β γ : Type} (f : α → γ) (g : β → γ) : α ⊕ β → γ :=
  λ s => match s with
  | Sum.inl a => f a
  | Sum.inr b => g b

def coproduct_injection1 {α β : Type} : α → α ⊕ β := Sum.inl
def coproduct_injection2 {α β : Type} : β → α ⊕ β := Sum.inr
```

### 1.11.3.3.4 逻辑推理规则 / Logical Inference Rules

```lean
-- 蕴含引入规则
def implication_intro {α β : Type} (f : α → β) : α → β := f

-- 蕴含消解规则
def implication_elim {α β : Type} (f : α → β) (a : α) : β := f a

-- 合取引入规则
def conjunction_intro {α β : Type} (a : α) (b : β) : α × β := (a, b)

-- 合取消解规则
def conjunction_elim1 {α β : Type} (p : α × β) : α := p.1
def conjunction_elim2 {α β : Type} (p : α × β) : β := p.2

-- 析取引入规则
def disjunction_intro1 {α β : Type} (a : α) : α ⊕ β := Sum.inl a
def disjunction_intro2 {α β : Type} (b : β) : α ⊕ β := Sum.inr b

-- 析取消解规则
def disjunction_elim {α β γ : Type} (s : α ⊕ β) (f : α → γ) (g : β → γ) : γ :=
  match s with
  | Sum.inl a => f a
  | Sum.inr b => g b
```

### 1.11.3.3.5 实际应用示例 / Practical Application Examples

```lean
-- 交换律的完整证明
theorem swap_correct {α β : Type} (a : α) (b : β) :
  swap_proof (a, b) = (b, a) := by
  simp [swap_proof]

-- 分配律的完整证明
theorem distrib_correct {α β γ : Type} (a : α) (b : β) :
  distrib_proof (a, Sum.inl b) = Sum.inl (a, b) := by
  simp [distrib_proof]

-- 指数对象的泛性质
theorem exponential_universal {α β γ : Type} (f : γ × α → β) :
  exponential_uncurry (exponential_object f) = f := by
  funext p
  cases p
  simp [exponential_object, exponential_uncurry]

-- 直积的泛性质
theorem product_universal_property {α β γ : Type} (f : γ → α) (g : γ → β) :
  product_projection1 ∘ product_universal f g = f ∧
  product_projection2 ∘ product_universal f g = g := by
  constructor
  · funext c
    simp [product_universal, product_projection1]
  · funext c
    simp [product_universal, product_projection2]
```

---

## 1.11.3.4 交叉引用 / Cross References

- [1.11-范畴论与类型理论.md](1.11-范畴论与类型理论.md)

---

## 1.11.3.5 2025 规范对齐 / Alignment with Lean 4 (2025)

- 将 CHL 对应落地为可验证映射：直积/直和/指数对象 ↔ `Prod`/`Sum`/`(→)` 之范畴解释；在 Lean 中以结构/实例呈现。
- 使用 `category` 相关实例（若依赖 mathlib4 的 `CategoryTheory`），需显式 `import` 并隔离到演示模块。

---

## 1.11.3.6 参考资料 / References

- 标准范畴论教材（极限/指数对象章节）
- Lean/Mathlib4 CategoryTheory 文档与示例

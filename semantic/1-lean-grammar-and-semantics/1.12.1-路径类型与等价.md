# 1.12.1 路径类型与等价 / Path Types and Equivalence

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.12-同伦类型论.md](1.12-同伦类型论.md)

---

## 1.12.1.1 核心定义 / Core Definition

**中文**：路径类型是同伦类型论的核心，类型中的等价被解释为“路径”，即元素间的连续变形。它将拓扑学中的路径概念引入类型理论，为数学提供了统一的几何视角。

**English**: Path types are central to Homotopy Type Theory (HoTT), where equivalence in types is interpreted as "paths", i.e., continuous deformations between elements. They introduce the concept of paths from topology into type theory, providing a unified geometric perspective for mathematics.

### 1.12.1.1.1 历史背景 / Historical Background

路径类型由Vladimir Voevodsky在同伦类型论中引入，将拓扑学中的路径概念与类型理论中的等价关系统一。这一思想源于代数拓扑，为数学基础提供了新的视角。

### 1.12.1.1.2 核心思想 / Core Ideas

1. **路径即等价**：类型中的等价关系对应拓扑空间中的路径
2. **连续变形**：路径表示元素间的连续变形过程
3. **几何直觉**：将抽象的类型关系几何化
4. **统一框架**：为数学提供统一的几何-代数框架

---

## 1.12.1.2 形式化模型 / Formal Model

### 1.12.1.2.1 路径类型定义 / Path Type Definition

路径类型 $\mathsf{Path}_A(a, b)$ 表示类型 $A$ 中从 $a$ 到 $b$ 的路径：

**形成规则**：
$$\frac{a : A \quad b : A}{\mathsf{Path}_A(a, b) : \text{Type}}$$

**引入规则**：
$$\frac{a : A}{\mathsf{refl}_a : \mathsf{Path}_A(a, a)}$$

**消除规则**：
$$\frac{p : \mathsf{Path}_A(a, b) \quad C : \mathsf{Path}_A(a, b) \to \text{Type} \quad c : C(\mathsf{refl}_a)}{\mathsf{J}(p, C, c) : C(p)}$$

### 1.12.1.2.2 路径运算 / Path Operations

**路径连接**：
$$p \cdot q : \mathsf{Path}_A(a, c) \text{ 其中 } p : \mathsf{Path}_A(a, b), q : \mathsf{Path}_A(b, c)$$

**路径反转**：
$$p^{-1} : \mathsf{Path}_A(b, a) \text{ 其中 } p : \mathsf{Path}_A(a, b)$$

**路径应用**：
$$f_*(p) : \mathsf{Path}_B(f(a), f(b)) \text{ 其中 } f : A \to B, p : \mathsf{Path}_A(a, b)$$

### 1.12.1.2.3 同伦等价 / Homotopy Equivalence

同伦等价 $A \simeq B$ 定义为：

$$A \simeq B := \sum_{f : A \to B} \sum_{g : B \to A} \left(\prod_{a : A} \mathsf{Path}_A(g(f(a)), a)\right) \times \left(\prod_{b : B} \mathsf{Path}_B(f(g(b)), b)\right)$$

即存在函数 $f : A \to B$ 和 $g : B \to A$，以及同伦 $f \circ g \sim \text{id}_B$ 和 $g \circ f \sim \text{id}_A$。

---

## 1.12.1.3 Lean 代码示例 / Lean Code Example

### 1.12.1.3.1 路径类型实现 / Path Type Implementation

```lean
-- 路径类型定义
inductive Path {A : Type} (a : A) : A → Type
| refl : Path a a

-- 路径连接
def path_concat {A : Type} {a b c : A} (p : Path a b) (q : Path b c) : Path a c :=
  match p, q with
  | Path.refl, q => q
  | p, Path.refl => p

-- 路径反转
def path_inv {A : Type} {a b : A} (p : Path a b) : Path b a :=
  match p with
  | Path.refl => Path.refl

-- 路径应用
def path_ap {A B : Type} (f : A → B) {a b : A} (p : Path a b) : Path (f a) (f b) :=
  match p with
  | Path.refl => Path.refl
```

### 1.12.1.3.2 同伦等价实现 / Homotopy Equivalence Implementation

```lean
-- 同伦等价结构
structure Equiv (A B : Type) : Type where
  to_fun : A → B
  inv_fun : B → A
  left_inv : ∀ a, Path (inv_fun (to_fun a)) a
  right_inv : ∀ b, Path (to_fun (inv_fun b)) b

-- 等价关系的性质
def is_equiv {A B : Type} (f : A → B) : Prop :=
  ∃ g : B → A, 
    (∀ a, Path (g (f a)) a) ∧ (∀ b, Path (f (g b)) b)

-- 路径运算的性质
theorem path_unit_left {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat Path.refl p) p := by
  cases p; simp

theorem path_assoc {A : Type} {a b c d : A} 
  (p : Path a b) (q : Path b c) (r : Path c d) :
  Path (path_concat (path_concat p q) r) (path_concat p (path_concat q r)) := by
  cases p; cases q; cases r; simp

-- 路径反转的性质
theorem path_inv_inv {A : Type} {a b : A} (p : Path a b) :
  Path (path_inv (path_inv p)) p := by
  cases p; simp 
      (∀ a, Path (g (f a)) a) ∧ 
    (∀ b, Path (f (g b)) b)

-- 高阶路径类型
inductive Path2 {A : Type} {a b : A} : Path a b → Path a b → Type
| refl : ∀ p : Path a b, Path2 p p

-- 三维路径类型
inductive Path3 {A : Type} {a b : A} {p q : Path a b} : Path2 p q → Path2 p q → Type
| refl : ∀ r : Path2 p q, Path3 r r

-- 路径类型的群结构
theorem path_group_laws {A : Type} {a : A} :
  -- 单位元
  Path (path_concat Path.refl Path.refl) Path.refl ∧
  -- 结合律
  (∀ p q r : Path a a, 
    Path (path_concat (path_concat p q) r) (path_concat p (path_concat q r))) ∧
  -- 逆元
  (∀ p : Path a a, 
    Path (path_concat p (path_inv p)) Path.refl) := by
  constructor
  · simp
  · intro p q r; cases p; cases q; cases r; simp
  · intro p; cases p; simp

-- 等价类型构造
def equiv_mk {A B : Type} (f : A → B) (g : B → A) 
  (h1 : ∀ a, Path (g (f a)) a) (h2 : ∀ b, Path (f (g b)) b) : Equiv A B :=
  { to_fun := f
    inv_fun := g
    left_inv := h1
    right_inv := h2
  }
```

### 1.12.1.3.3 路径代数 / Path Algebra

```lean
-- 路径的单位律
theorem path_unit_left {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat Path.refl p) p := by
  cases p
  rfl

theorem path_unit_right {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat p Path.refl) p := by
  cases p
  rfl

-- 路径的结合律
theorem path_assoc {A : Type} {a b c d : A} 
  (p : Path a b) (q : Path b c) (r : Path c d) :
  Path (path_concat (path_concat p q) r) (path_concat p (path_concat q r)) := by
  cases p <;> cases q <;> cases r
  rfl

-- 路径的逆律
theorem path_inv_left {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat (path_inv p) p) Path.refl := by
  cases p
  rfl

theorem path_inv_right {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat p (path_inv p)) Path.refl := by
  cases p
  rfl
```

### 1.12.1.3.4 具体示例 / Concrete Examples

```lean
-- 自然数加法的路径
def add_zero_path (n : Nat) : Path (n + 0) n := by
  induction n with
  | zero => exact Path.refl
  | succ k ih => 
    simp [Nat.add_succ]
    exact path_ap Nat.succ ih

-- 列表反转的路径
def reverse_reverse_path {A : Type} (xs : List A) : Path (reverse (reverse xs)) xs := by
  induction xs with
  | nil => exact Path.refl
  | cons x xs ih => 
    simp [reverse, append]
    exact path_ap (List.cons x) ih

-- 类型等价的例子：Bool 和 Unit + Unit
def bool_to_sum : Bool → Unit ⊕ Unit
| Bool.true => Sum.inl Unit.unit
| Bool.false => Sum.inr Unit.unit

def sum_to_bool : Unit ⊕ Unit → Bool
| Sum.inl _ => Bool.true
| Sum.inr _ => Bool.false

-- 证明等价
def bool_equiv_sum : Equiv Bool (Unit ⊕ Unit) :=
  equiv_mk bool_to_sum sum_to_bool
    (λ b => by cases b <;> rfl)
    (λ s => by cases s <;> rfl)
```

---

## 1.12.1.4 理论意义与应用 / Theoretical Significance and Applications

### 1.12.1.4.1 数学基础统一 / Unification of Mathematical Foundations

路径类型为数学提供了统一的几何视角：

- **拓扑学**：路径对应连续变形
- **代数**：路径对应代数关系
- **几何**：路径对应几何变换
- **逻辑**：路径对应逻辑等价

### 1.12.1.4.2 计算意义 / Computational Significance

- **程序等价**：等价程序可以互换
- **优化机会**：基于等价性进行优化
- **类型安全**：保证程序类型安全
- **模块化**：支持模块化程序设计

### 1.12.1.4.3 前沿研究方向 / Frontier Research Directions

- **AI辅助证明**：自动化路径构造
- **可视化工具**：路径可视化
- **工程应用**：在大型系统中的应用
- **教育推广**：HoTT的教学方法

## 1.12.1.5 交叉引用 / Cross References

- [1.12-同伦类型论.md](1.12-同伦类型论.md) - HoTT基础理论
- [1.12.2-单值性公理.md](1.12.2-单值性公理.md) - 单值性公理
- [1.12.3-高阶等价与∞-范畴.md](1.12.3-高阶等价与∞-范畴.md) - 高阶结构

---

## 1.12.1.6 2025 规范对齐 / Alignment with Lean 4 (2025)

### 1.12.1.6.1 路径类型实现 / Path Type Implementation

- **公理化引入**：路径类型在HoTT中对应 `a = b`，在Lean中通过公理化方式引入
- **结构定义**：等价类型 `A ≃ B` 应通过结构定义，包含函数、逆函数与同伦证明
- **计算性分离**：避免将HoTT扩展混入核心计算路径，保持可计算性

### 1.12.1.6.2 最佳实践 / Best Practices

- **类型安全**：保证路径类型的安全性
- **性能优化**：避免不必要的路径计算
- **接口设计**：提供清晰的路径操作接口
- **文档说明**：详细说明路径类型的使用方法

### 1.12.1.6.3 扩展开发 / Extension Development

- **独立库**：将路径类型作为独立库开发
- **版本管理**：明确标注版本兼容性
- **测试验证**：充分的测试和验证
- **社区反馈**：收集社区反馈并改进

---

## 1.12.1.7 版本兼容性 / Version Compatibility

### 1.12.1.7.1 Lean版本支持 / Lean Version Support

- **Lean 4**：基础内核不内置HoTT扩展
- **扩展库**：需要安装专门的HoTT库
- **版本管理**：明确标注扩展库的版本要求

### 1.12.1.7.2 接口稳定性 / Interface Stability

- **实验性接口**：标注实验性功能的稳定性
- **公共接口**：优先使用已验证的公共接口
- **向后兼容**：保证接口的向后兼容性

## 1.12.1.8 参考资料 / References

### 1.12.1.8.1 经典文献 / Classic Literature

- **HoTT Book**：路径类型的详细讨论
- **Voevodsky论文**：路径类型的原始提出
- **类型论教材**：路径类型在类型论中的地位

### 1.12.1.8.2 社区资源 / Community Resources

- **Lean/HoTT社区**：最新的发展和讨论
- **在线教程**：路径类型的学习资源
- **开源项目**：相关的开源实现

### 1.12.1.8.3 进一步阅读 / Further Reading

- **同伦论基础**：理解路径类型的数学背景
- **范畴论应用**：路径类型在范畴论中的应用
- **计算机科学应用**：路径类型在编程语言中的应用
- 路径类型与等价的公理化定义应明确标注为扩展。

---

## 1.12.1.7 参考资料 / References

- HoTT Book（Path Types & Equivalences）
- Lean/HoTT 社区资源

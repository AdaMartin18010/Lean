# 1.12.1 路径类型与等价 / Path Types and Equivalence

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.12-同伦类型论.md](1.12-同伦类型论.md)

---

## 1.12.1.1 核心定义 / Core Definition

**中文**：路径类型是同伦类型论的核心，类型中的等价被解释为“路径”，即元素间的连续变形。它将拓扑学中的路径概念引入类型理论，为数学提供了统一的几何视角。

**English**: Path types are central to Homotopy Type Theory (HoTT), where equivalence in types is interpreted as "paths", i.e., continuous deformations between elements. They introduce the concept of paths from topology into type theory, providing a unified geometric perspective for mathematics.

### 1.12.1.1.1 历史背景 / Historical Background

路径类型由Vladimir Voevodsky在同伦类型论中引入，将拓扑学中的路径概念与类型理论中的等价关系统一。这一思想源于代数拓扑，为数学基础提供了新的视角。

### 1.12.1.1.2 核心思想 / Core Ideas

1. **路径即等价**：类型中的等价关系对应拓扑空间中的路径
2. **连续变形**：路径表示元素间的连续变形过程
3. **几何直觉**：将抽象的类型关系几何化
4. **统一框架**：为数学提供统一的几何-代数框架

---

## 1.12.1.2 形式化模型 / Formal Model

### 1.12.1.2.1 路径类型定义 / Path Type Definition

路径类型 $\mathsf{Path}_A(a, b)$ 表示类型 $A$ 中从 $a$ 到 $b$ 的路径：

**形成规则**：
$$\frac{a : A \quad b : A}{\mathsf{Path}_A(a, b) : \text{Type}}$$

**引入规则**：
$$\frac{a : A}{\mathsf{refl}_a : \mathsf{Path}_A(a, a)}$$

**消除规则**：
$$\frac{p : \mathsf{Path}_A(a, b) \quad C : \mathsf{Path}_A(a, b) \to \text{Type} \quad c : C(\mathsf{refl}_a)}{\mathsf{J}(p, C, c) : C(p)}$$

### 1.12.1.2.2 路径运算 / Path Operations

**路径连接**：
$$p \cdot q : \mathsf{Path}_A(a, c) \text{ 其中 } p : \mathsf{Path}_A(a, b), q : \mathsf{Path}_A(b, c)$$

**路径反转**：
$$p^{-1} : \mathsf{Path}_A(b, a) \text{ 其中 } p : \mathsf{Path}_A(a, b)$$

**路径应用**：
$$f_*(p) : \mathsf{Path}_B(f(a), f(b)) \text{ 其中 } f : A \to B, p : \mathsf{Path}_A(a, b)$$

### 1.12.1.2.3 同伦等价 / Homotopy Equivalence

同伦等价 $A \simeq B$ 定义为：

$$A \simeq B := \sum_{f : A \to B} \sum_{g : B \to A} \left(\prod_{a : A} \mathsf{Path}_A(g(f(a)), a)\right) \times \left(\prod_{b : B} \mathsf{Path}_B(f(g(b)), b)\right)$$

即存在函数 $f : A \to B$ 和 $g : B \to A$，以及同伦 $f \circ g \sim \text{id}_B$ 和 $g \circ f \sim \text{id}_A$。

---

## 1.12.1.3 Lean 代码示例 / Lean Code Example

### 1.12.1.3.1 路径类型实现 / Path Type Implementation

```lean
-- 路径类型定义
inductive Path {A : Type} (a : A) : A → Type
| refl : Path a a

-- 路径连接
def path_concat {A : Type} {a b c : A} (p : Path a b) (q : Path b c) : Path a c :=
  match p, q with
  | Path.refl, q => q
  | p, Path.refl => p

-- 路径反转
def path_inv {A : Type} {a b : A} (p : Path a b) : Path b a :=
  match p with
  | Path.refl => Path.refl

-- 路径应用
def path_ap {A B : Type} (f : A → B) {a b : A} (p : Path a b) : Path (f a) (f b) :=
  match p with
  | Path.refl => Path.refl
```

### 1.12.1.3.2 同伦等价实现 / Homotopy Equivalence Implementation

```lean
-- 同伦等价结构
structure Equiv (A B : Type) : Type where
  to_fun : A → B
  inv_fun : B → A
  left_inv : ∀ a, Path (inv_fun (to_fun a)) a
  right_inv : ∀ b, Path (to_fun (inv_fun b)) b

-- 等价关系的性质
def is_equiv {A B : Type} (f : A → B) : Prop :=
  ∃ g : B → A, 
  (∀ a, Path (g (f a)) a) ∧ 
  (∀ b, Path (f (g b)) b)

-- 等价类型构造
def equiv_mk {A B : Type} (f : A → B) (g : B → A) 
  (h1 : ∀ a, Path (g (f a)) a) (h2 : ∀ b, Path (f (g b)) b) : Equiv A B :=
  { to_fun := f
    inv_fun := g
    left_inv := h1
    right_inv := h2
  }
```

### 1.12.1.3.3 路径代数 / Path Algebra

```lean
-- 路径的单位律
theorem path_unit_left {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat Path.refl p) p := by
  cases p
  rfl

theorem path_unit_right {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat p Path.refl) p := by
  cases p
  rfl

-- 路径的结合律
theorem path_assoc {A : Type} {a b c d : A} 
  (p : Path a b) (q : Path b c) (r : Path c d) :
  Path (path_concat (path_concat p q) r) (path_concat p (path_concat q r)) := by
  cases p <;> cases q <;> cases r
  rfl

-- 路径的逆律
theorem path_inv_left {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat (path_inv p) p) Path.refl := by
  cases p
  rfl

theorem path_inv_right {A : Type} {a b : A} (p : Path a b) :
  Path (path_concat p (path_inv p)) Path.refl := by
  cases p
  rfl
```

### 1.12.1.3.4 具体示例 / Concrete Examples

```lean
-- 自然数加法的路径
def add_zero_path (n : Nat) : Path (n + 0) n := by
  induction n with
  | zero => exact Path.refl
  | succ k ih => 
    simp [Nat.add_succ]
    exact path_ap Nat.succ ih

-- 列表反转的路径
def reverse_reverse_path {A : Type} (xs : List A) : Path (reverse (reverse xs)) xs := by
  induction xs with
  | nil => exact Path.refl
  | cons x xs ih => 
    simp [reverse, append]
    exact path_ap (List.cons x) ih

-- 类型等价的例子：Bool 和 Unit + Unit
def bool_to_sum : Bool → Unit ⊕ Unit
| Bool.true => Sum.inl Unit.unit
| Bool.false => Sum.inr Unit.unit

def sum_to_bool : Unit ⊕ Unit → Bool
| Sum.inl _ => Bool.true
| Sum.inr _ => Bool.false

-- 证明等价
def bool_equiv_sum : Equiv Bool (Unit ⊕ Unit) :=
  equiv_mk bool_to_sum sum_to_bool
    (λ b => by cases b <;> rfl)
    (λ s => by cases s <;> rfl)
```

---

## 1.12.1.4 交叉引用 / Cross References

- [1.12-同伦类型论.md](1.12-同伦类型论.md)

---

## 1.12.1.5 2025 规范对齐 / Alignment with Lean 4 (2025)

- 路径类型在HoTT中对应 `a = b`，在Lean中通过公理化方式引入。
- 等价类型 `A ≃ B` 应通过结构定义，包含函数、逆函数与同伦证明。
- 避免将HoTT扩展混入核心计算路径，保持可计算性。

---

## 1.12.1.6 版本兼容性 / Version Compatibility

- Lean 4 基础内核不内置HoTT；若使用相关扩展，需标注来源。
- 路径类型与等价的公理化定义应明确标注为扩展。

---

## 1.12.1.7 参考资料 / References

- HoTT Book（Path Types & Equivalences）
- Lean/HoTT 社区资源

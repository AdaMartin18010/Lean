# 1.9.3 归纳证明与递归原理 / Inductive Proofs and Recursion Principle

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.9.2-序列演算.md](1.9.2-序列演算.md)

---

## 1.9.3.1 核心定义 / Core Definition

**中文**：归纳证明是一种基于结构递归的证明方法，广泛用于自然数、数据结构等的性质证明。它通过证明基础情况和归纳步骤来建立一般性结论，是形式化证明的核心技术。

**English**: Inductive proof is a proof method based on structural recursion, widely used for proving properties of natural numbers, data structures, etc. It establishes general conclusions by proving base cases and inductive steps, making it a core technique in formal proof.

### 1.9.3.1.1 历史背景 / Historical Background

归纳证明起源于Peano公理系统，由Giuseppe Peano在1889年提出。它基于数学归纳原理，为自然数和其他归纳定义的结构提供了严格的证明方法。

### 1.9.3.1.2 核心思想 / Core Ideas

1. **基础情况**：证明命题对最小元素成立
2. **归纳步骤**：假设对较小元素成立，证明对较大元素也成立
3. **结构递归**：基于数据结构的定义进行递归证明
4. **良基性**：确保归纳过程能够终止

---

## 1.9.3.2 形式化模型 / Formal Model

### 1.9.3.2.1 数学归纳法 / Mathematical Induction

数学归纳法用于自然数：

**原理**：设 $P(n)$ 是关于自然数 $n$ 的命题，如果：

1. $P(0)$ 成立（基础情况）
2. 对于任意 $k \in \mathbb{N}$，如果 $P(k)$ 成立，则 $P(k+1)$ 成立（归纳步骤）

那么对于所有自然数 $n$，$P(n)$ 都成立。

**形式化表达**：
$$\frac{P(0) \quad \forall k, P(k) \to P(k+1)}{\forall n, P(n)}$$

### 1.9.3.2.2 结构归纳法 / Structural Induction

结构归纳法用于归纳定义的数据结构：

**原理**：对于归纳定义的类型 $T$，如果：

1. 基础构造子的性质成立
2. 归纳构造子保持性质

那么所有 $T$ 的元素都满足该性质。

**示例**：对于列表 $L$，如果：

- $P([])$ 成立
- 对于任意 $x$ 和 $xs$，如果 $P(xs)$ 成立，则 $P(x :: xs)$ 成立

那么对于所有列表 $L$，$P(L)$ 成立。

### 1.9.3.2.3 递归原理 / Recursion Principle

递归原理允许我们基于归纳定义构造函数：

**自然数递归**：
$$\frac{c : C(0) \quad f : \forall n, C(n) \to C(n+1)}{\text{rec}(c, f) : \forall n, C(n)}$$

**列表递归**：
$$\frac{c : C([]) \quad f : \forall x \, xs, C(xs) \to C(x :: xs)}{\text{rec}(c, f) : \forall xs, C(xs)}$$

---

## 1.9.3.3 Lean 代码示例 / Lean Code Example

### 1.9.3.3.1 数学归纳法示例 / Mathematical Induction Examples

```lean
-- 自然数加法性质
lemma add_zero (n : Nat) : n + 0 = n := by
  induction n with
  | zero => 
    simp [Nat.add_zero]
  | succ k ih => 
    simp [Nat.add_succ]
    exact congrArg Nat.succ ih

-- 自然数乘法性质
lemma mul_zero (n : Nat) : n * 0 = 0 := by
  induction n with
  | zero => 
    simp [Nat.mul_zero]
  | succ k ih => 
    simp [Nat.mul_succ]
    exact ih

-- 自然数幂的性质
lemma pow_one (n : Nat) : n ^ 1 = n := by
  induction n with
  | zero => 
    simp [Nat.pow_zero, Nat.pow_one]
  | succ k ih => 
    simp [Nat.pow_succ]
    exact congrArg Nat.succ ih
```

### 1.9.3.3.2 结构归纳法示例 / Structural Induction Examples

```lean
-- 列表长度性质
lemma length_append {α : Type} (xs ys : List α) : 
  (xs ++ ys).length = xs.length + ys.length := by
  induction xs with
  | nil => 
    simp [List.append, List.length]
  | cons x xs ih => 
    simp [List.append, List.length]
    exact congrArg Nat.succ ih

-- 列表反转性质
lemma reverse_reverse {α : Type} (xs : List α) : 
  reverse (reverse xs) = xs := by
  induction xs with
  | nil => 
    simp [reverse]
  | cons x xs ih => 
    simp [reverse, append]
    rw [ih]

-- 列表映射性质
lemma map_append {α β : Type} (f : α → β) (xs ys : List α) :
  map f (xs ++ ys) = map f xs ++ map f ys := by
  induction xs with
  | nil => 
    simp [map, append]
  | cons x xs ih => 
    simp [map, append]
    exact congrArg (List.cons (f x)) ih
```

### 1.9.3.3.3 递归原理示例 / Recursion Principle Examples

```lean
-- 使用递归原理定义函数
def factorial : Nat → Nat
| 0 => 1
| n + 1 => (n + 1) * factorial n

-- 递归函数的终止性证明
theorem factorial_terminates (n : Nat) : factorial n ≠ 0 := by
  induction n with
  | zero => 
    simp [factorial]
  | succ k ih => 
    simp [factorial]
    apply Nat.mul_ne_zero
    · simp
    · exact ih

-- 斐波那契数列
def fibonacci : Nat → Nat
| 0 => 0
| 1 => 1
| n + 2 => fibonacci n + fibonacci (n + 1)

-- 斐波那契数列的性质
theorem fibonacci_positive (n : Nat) : n > 0 → fibonacci n > 0 := by
  induction n with
  | zero => 
    intro h
    contradiction
  | succ 0 => 
    intro h
    simp [fibonacci]
  | succ (succ k) ih => 
    intro h
    simp [fibonacci]
    apply Nat.add_pos
    · apply ih
      simp
    · apply ih
      simp
```

### 1.9.3.3.4 高级归纳示例 / Advanced Induction Examples

```lean
-- 强归纳法
theorem strong_induction (P : Nat → Prop)
  (h : ∀ n, (∀ m, m < n → P m) → P n) :
  ∀ n, P n := by
  intro n
  apply h
  intro m h_lt
  apply strong_induction P h
  exact h_lt

-- 双重归纳
theorem double_induction (P : Nat → Nat → Prop)
  (h_zero : ∀ n, P 0 n)
  (h_succ : ∀ m n, P m n → P (m + 1) n)
  (h_step : ∀ m n, P m n → P m (n + 1)) :
  ∀ m n, P m n := by
  intro m n
  induction m with
  | zero => 
    exact h_zero n
  | succ k ih => 
    apply h_succ
    exact ih

-- 良基归纳
theorem well_founded_induction {α : Type} (r : α → α → Prop) [WellFounded r]
  (P : α → Prop) (h : ∀ x, (∀ y, r y x → P y) → P x) :
  ∀ x, P x := by
  intro x
  apply h
  intro y h_lt
  apply well_founded_induction r P h
  exact h_lt
```

---

## 1.9.3.4 交叉引用 / Cross References

- [1.9-证明论与推理系统.md](1.9-证明论与推理系统.md)

---

## 1.9.3.5 2025 规范对齐 / Alignment with Lean 4 (2025)

- 结构归纳与良基递归：优先结构归纳；必要时使用 `termination_by`/`decreasing_by` 给出终止性证明。
- 归纳原理中引入的归纳假设应限制作用域，避免污染全局上下文。

---

## 1.9.3.6 版本兼容性 / Version Compatibility

- 归纳定义/递归在 Lean 3/4 间基本一致；终止性语法在 Lean 4 更清晰。

---

## 1.9.3.7 参考资料 / References

- 归纳法与递归理论教材
- Lean 4 Reference Manual（Inductive/Recursion）

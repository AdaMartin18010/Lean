# 1.10.1 操作语义 / Operational Semantics

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.10-模型论与语义模型.md](1.10-模型论与语义模型.md)

---

## 1.10.1.1 核心定义 / Core Definition

**中文**：操作语义通过定义程序执行的具体步骤，描述程序的行为，是编程语言语义分析的基础方法之一。它关注程序如何一步步执行，通过状态转换规则定义程序的动态行为。

**English**: Operational semantics describes the behavior of programs by defining the concrete steps of program execution, serving as a fundamental approach to programming language semantics. It focuses on how programs execute step by step, defining the dynamic behavior of programs through state transition rules.

### 1.10.1.1.1 历史背景 / Historical Background

操作语义由Gordon Plotkin在1981年提出，作为结构化操作语义（SOS）的基础。它提供了一种形式化描述程序执行过程的方法，广泛应用于编程语言理论和编译器设计。

### 1.10.1.1.2 核心思想 / Core Ideas

1. **状态转换**：程序执行是状态之间的转换
2. **逐步执行**：程序通过一系列小步骤执行
3. **规则驱动**：执行由预定义的规则控制
4. **终止条件**：程序执行到无法继续转换的状态

---

## 1.10.1.2 形式化模型 / Formal Model

### 1.10.1.2.1 小步语义 / Small-Step Semantics

小步语义定义程序执行的单个步骤：

**语法**：
$$\frac{\text{前提}}{\text{结论}}$$

**示例规则**：

- **值规则**：$v \not\rightarrow$ （值不能继续执行）
- **加法规则**：$\frac{e_1 \rightarrow e_1'}{e_1 + e_2 \rightarrow e_1' + e_2}$
- **加法完成**：$\frac{e_2 \rightarrow e_2'}{v_1 + e_2 \rightarrow v_1 + e_2'}$
- **加法计算**：$n_1 + n_2 \rightarrow n_1 + n_2$

### 1.10.1.2.2 大步语义 / Big-Step Semantics

大步语义直接定义表达式的最终结果：

**语法**：
$$\frac{\text{前提}}{\text{结论}}$$

**示例规则**：

- **值规则**：$v \Downarrow v$
- **加法规则**：$\frac{e_1 \Downarrow n_1 \quad e_2 \Downarrow n_2}{e_1 + e_2 \Downarrow n_1 + n_2}$

### 1.10.1.2.3 状态转移系统 / State Transition System

状态转移系统定义程序状态的变化：

**状态**：$\langle \text{程序}, \text{环境}, \text{存储} \rangle$

**转移关系**：$\langle e, \sigma \rangle \rightarrow \langle e', \sigma' \rangle$

其中：

- $e$ 是当前表达式
- $\sigma$ 是当前状态
- $e'$ 是下一步表达式
- $\sigma'$ 是下一步状态

---

## 1.10.1.3 Lean 代码示例 / Lean Code Example

### 1.10.1.3.1 小步语义实现 / Small-Step Semantics Implementation

```lean
-- 表达式语法
inductive Expr : Type
| val : Nat → Expr
| add : Expr → Expr → Expr
| mul : Expr → Expr → Expr

-- 小步语义：单步执行
inductive Step : Expr → Expr → Prop
| add_left : ∀ e1 e1' e2, Step e1 e1' → Step (Expr.add e1 e2) (Expr.add e1' e2)
| add_right : ∀ v1 e2 e2', Step e2 e2' → Step (Expr.add (Expr.val v1) e2) (Expr.add (Expr.val v1) e2')
| add_compute : ∀ n1 n2, Step (Expr.add (Expr.val n1) (Expr.val n2)) (Expr.val (n1 + n2))
| mul_left : ∀ e1 e1' e2, Step e1 e1' → Step (Expr.mul e1 e2) (Expr.mul e1' e2)
| mul_right : ∀ v1 e2 e2', Step e2 e2' → Step (Expr.mul (Expr.val v1) e2) (Expr.mul (Expr.val v1) e2')
| mul_compute : ∀ n1 n2, Step (Expr.mul (Expr.val n1) (Expr.val n2)) (Expr.val (n1 * n2))

-- 多步执行
inductive Steps : Expr → Expr → Prop
| refl : ∀ e, Steps e e
| trans : ∀ e1 e2 e3, Step e1 e2 → Steps e2 e3 → Steps e1 e3
```

### 1.10.1.3.2 大步语义实现 / Big-Step Semantics Implementation

```lean
-- 大步语义：直接求值
inductive Eval : Expr → Nat → Prop
| val : ∀ n, Eval (Expr.val n) n
| add : ∀ e1 e2 n1 n2, Eval e1 n1 → Eval e2 n2 → Eval (Expr.add e1 e2) (n1 + n2)
| mul : ∀ e1 e2 n1 n2, Eval e1 n1 → Eval e2 n2 → Eval (Expr.mul e1 e2) (n1 * n2)

-- 大步语义与小步语义的关系
theorem big_step_implies_steps : ∀ e n, Eval e n → Steps e (Expr.val n) := by
  intro e n h
  induction h
  · apply Steps.refl
  · apply Steps.trans
    · apply Step.add_compute
    · assumption
  · apply Steps.trans
    · apply Step.mul_compute
    · assumption

-- 小步语义到大步语义
theorem steps_implies_big_step : ∀ e n, Steps e (Expr.val n) → Eval e n := by
  intro e n h
  induction h
  · assumption
  · sorry -- 需要更复杂的归纳
inductive Eval : Expr → Nat → Prop
| val : ∀ n, Eval (Expr.val n) n
| add : ∀ e1 e2 n1 n2, Eval e1 n1 → Eval e2 n2 → Eval (Expr.add e1 e2) (n1 + n2)
| mul : ∀ e1 e2 n1 n2, Eval e1 n1 → Eval e2 n2 → Eval (Expr.mul e1 e2) (n1 * n2)

-- 函数式求值器
def eval : Expr → Nat
| Expr.val n => n
| Expr.add e1 e2 => eval e1 + eval e2
| Expr.mul e1 e2 => eval e1 * eval e2
```

### 1.10.1.3.3 状态转移系统 / State Transition System

```lean
-- 程序状态
structure State : Type where
  expr : Expr
  env : List (String × Nat)  -- 变量环境
  store : List (String × Nat)  -- 存储

-- 状态转移关系
inductive StateStep : State → State → Prop
| eval_expr : ∀ s s', Step s.expr s'.expr → 
  s.env = s'.env → s.store = s'.store → StateStep s s'
| update_env : ∀ s x v, StateStep s { s with env := (x, v) :: s.env }
| update_store : ∀ s x v, StateStep s { s with store := (x, v) :: s.store }

-- 带环境的求值
def eval_with_env : Expr → List (String × Nat) → Nat
| Expr.val n, _ => n
| Expr.add e1 e2, env => eval_with_env e1 env + eval_with_env e2 env
| Expr.mul e1 e2, env => eval_with_env e1 env * eval_with_env e2 env
```

### 1.10.1.3.4 语义等价性证明 / Semantic Equivalence Proof

```lean
-- 证明小步语义和大步语义的等价性
theorem small_big_equiv (e : Expr) (n : Nat) : 
  (∃ e', Steps e e' ∧ Eval e' n) ↔ Eval e n := by
  constructor
  · intro h
    cases h with
    | intro e' h_steps h_eval =>
      -- 证明小步执行到值后，大步语义也得到相同值
      sorry
  · intro h_eval
    -- 证明大步语义可以分解为小步执行
    sorry

-- 证明函数式求值器与语义的一致性
theorem eval_consistent (e : Expr) : Eval e (eval e) := by
  induction e with
  | val n => exact Eval.val n
  | add e1 e2 ih1 ih2 => 
    exact Eval.add e1 e2 (eval e1) (eval e2) ih1 ih2
  | mul e1 e2 ih1 ih2 => 
    exact Eval.mul e1 e2 (eval e1) (eval e2) ih1 ih2
```

---

## 1.10.1.4 理论意义与应用 / Theoretical Significance and Applications

### 1.10.1.4.1 编程语言理论 / Programming Language Theory

操作语义为编程语言提供了理论基础：

- **语言设计**：指导编程语言的设计和实现
- **语义定义**：为编程语言提供精确的语义定义
- **编译器设计**：指导编译器的设计和实现
- **程序验证**：支持程序的正确性验证

### 1.10.1.4.2 计算机科学应用 / Computer Science Applications

- **编译器理论**：编译器的语义保持证明
- **程序分析**：程序行为的静态分析
- **并发系统**：并发程序的行为分析
- **安全系统**：程序安全性的形式化分析

### 1.10.1.4.3 工程实践 / Engineering Practice

- **语言实现**：编程语言的实际实现
- **工具开发**：程序分析和验证工具
- **标准制定**：编程语言标准的制定
- **教育推广**：编程语言理论的教学

## 1.10.1.5 交叉引用 / Cross References

- [1.10-模型论与语义模型.md](1.10-模型论与语义模型.md) - 语义模型基础
- [1.10.2-指称语义.md](1.10.2-指称语义.md) - 指称语义方法
- [1.10.3-公理语义.md](1.10.3-公理语义.md) - 公理语义方法

---

## 1.10.1.6 2025 规范对齐 / Alignment with Lean 4 (2025)

### 1.10.1.6.1 语义实现 / Semantic Implementation

- **归纳关系**：操作语义在Lean中通过归纳关系 `→` 实现，表示程序状态转换
- **类型定义**：小步语义与大步语义应通过不同的归纳类型或关系定义
- **可验证性**：语义规则应可验证，避免使用不可计算的元逻辑

### 1.10.1.6.2 最佳实践 / Best Practices

- **清晰定义**：语义规则应该清晰明确
- **一致性**：保证语义规则的一致性
- **完整性**：语义规则应该完整覆盖所有情况
- **可读性**：语义规则应该易于理解和验证

### 1.10.1.6.3 扩展开发 / Extension Development

- **模块化**：语义规则应该模块化设计
- **可扩展性**：支持语义规则的扩展
- **测试验证**：充分的测试和验证
- **文档说明**：详细的文档说明

---

## 1.10.1.7 版本兼容性 / Version Compatibility

### 1.10.1.7.1 Lean版本支持 / Lean Version Support

- **Lean 3/4兼容**：操作语义的定义方式在Lean 3/4间基本兼容
- **语义库**：若使用程序语言语义库，需标注版本与依赖
- **功能扩展**：Lean 4 提供了更多的功能扩展

### 1.10.1.7.2 兼容性考虑 / Compatibility Considerations

- **向后兼容**：保证向后兼容性
- **功能测试**：充分测试功能兼容性
- **文档更新**：及时更新相关文档

## 1.10.1.8 参考资料 / References

### 1.10.1.8.1 经典文献 / Classic Literature

- **Plotkin论文**：结构化操作语义的原始提出
- **程序语言语义学教材**：操作语义的详细讨论
- **语义学教材**：语义学基础理论

### 1.10.1.8.2 现代资源 / Modern Resources

- **Lean程序语义相关文档**：操作语义的实现示例
- **在线教程**：操作语义的学习资源
- **开源项目**：相关的开源实现

### 1.10.1.8.3 进一步阅读 / Further Reading

- **指称语义**：与操作语义的关系
- **公理语义**：另一种语义方法
- **并发语义**：并发程序的操作语义

---

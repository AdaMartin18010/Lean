# 1.12 HoTT核心概念完整版 / Complete HoTT Core Concepts

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.11-范畴论与类型理论.md](1.11-范畴论与类型理论.md) | [下一节: 1.13-高级主题.md](1.13-高级主题.md)

---

## 概述 / Overview

**中文**：同伦类型论（Homotopy Type Theory, HoTT）是类型论与同伦论的结合，通过路径类型、等价和单值性公理等核心概念，为数学和计算机科学提供了新的理论基础。

**English**: Homotopy Type Theory (HoTT) combines type theory with homotopy theory, providing new theoretical foundations for mathematics and computer science through core concepts like path types, equivalence, and the univalence axiom.

---

## 理论基础 / Theoretical Foundation

### 历史发展 / Historical Development

HoTT的发展经历了几个重要阶段：

1. **2000年代初期**：Voevodsky提出同伦类型论思想
2. **2006年**：单值性公理的提出
3. **2013年**：HoTT Book的出版
4. **2010年代后期**：在数学和计算机科学中的应用

### 核心思想 / Core Ideas

- **类型即空间**：类型被解释为拓扑空间
- **路径即证明**：类型中的等价被解释为路径
- **单值性**：等价类型可以互换
- **高阶结构**：n-路径和∞-范畴

---

## 路径类型 / Path Types

### 核心定义 / Core Definition

**中文**：路径类型是同伦类型论的核心，类型中的等价被解释为"路径"，即元素间的连续变形。

**English**: Path types are central to Homotopy Type Theory (HoTT), where equivalence in types is interpreted as "paths", i.e., continuous deformations between elements.

### 基本概念 / Basic Concepts

```lean
-- 路径类型的基本定义
inductive Path {A : Type} (a : A) : A → Type where
  | refl : Path a a

-- 路径的对称性
def path_symm {A : Type} {a b : A} (p : Path a b) : Path b a :=
  match p with
  | Path.refl => Path.refl

-- 路径的传递性
def path_trans {A : Type} {a b c : A} (p : Path a b) (q : Path b c) : Path a c :=
  match p, q with
  | Path.refl, Path.refl => Path.refl

-- 路径的群结构
theorem path_group_laws {A : Type} {a b c d : A} :
  (p : Path a b) → (q : Path b c) → (r : Path c d) →
  path_trans (path_trans p q) r = path_trans p (path_trans q r) :=
  fun p q r => by
    cases p; cases q; cases r
    rfl

-- 路径的逆元
theorem path_inverse {A : Type} {a b : A} (p : Path a b) :
  path_trans p (path_symm p) = Path.refl :=
  match p with
  | Path.refl => rfl
```

### 路径类型与等式 / Path Types and Equality

```lean
-- 路径类型与命题等式的对应
def path_to_eq {A : Type} {a b : A} (p : Path a b) : a = b :=
  match p with
  | Path.refl => rfl

def eq_to_path {A : Type} {a b : A} (h : a = b) : Path a b :=
  match h with
  | rfl => Path.refl

-- 路径类型的函数外延性
def function_extensionality {A B : Type} {f g : A → B} 
  (h : ∀ x, Path (f x) (g x)) : Path f g :=
  -- 在HoTT中，函数外延性是可证明的
  sorry

-- 路径类型的类型外延性
def type_extensionality {A B : Type} (h : A ≃ B) : Path A B :=
  -- 这需要单值性公理
  sorry
```

### 路径类型的代数结构 / Algebraic Structure of Path Types

```lean
-- 路径类型的群结构
structure PathGroup (A : Type) where
  carrier : Type
  unit : carrier
  mul : carrier → carrier → carrier
  inv : carrier → carrier
  assoc : ∀ x y z, mul (mul x y) z = mul x (mul y z)
  left_unit : ∀ x, mul unit x = x
  right_unit : ∀ x, mul x unit = x
  left_inv : ∀ x, mul (inv x) x = unit
  right_inv : ∀ x, mul x (inv x) = unit

-- 从路径类型构造群
def path_group {A : Type} (a : A) : PathGroup A :=
  { carrier := Path a a
    unit := Path.refl
    mul := path_trans
    inv := path_symm
    assoc := fun p q r => path_group_laws p q r
    left_unit := fun p => by cases p; rfl
    right_unit := fun p => by cases p; rfl
    left_inv := fun p => path_inverse p
    right_inv := fun p => path_inverse (path_symm p) }
```

---

## 等价 / Equivalence

### 1核心定义 / Core Definition

**中文**：等价是同伦类型论中的核心概念，表示两个类型之间的同构关系，包含函数、逆函数和同伦证明。

**English**: Equivalence is a core concept in HoTT, representing isomorphism between types, including functions, inverse functions, and homotopy proofs.

### 等价的结构 / Structure of Equivalence

```lean
-- 等价的基本定义
structure Equiv (A B : Type) where
  to_fun : A → B
  inv_fun : B → A
  left_inv : ∀ x, Path (inv_fun (to_fun x)) x
  right_inv : ∀ x, Path (to_fun (inv_fun x)) x

-- 等价的自反性
def equiv_refl {A : Type} : Equiv A A :=
  { to_fun := id
    inv_fun := id
    left_inv := fun x => Path.refl
    right_inv := fun x => Path.refl }

-- 等价的对称性
def equiv_symm {A B : Type} (e : Equiv A B) : Equiv B A :=
  { to_fun := e.inv_fun
    inv_fun := e.to_fun
    left_inv := e.right_inv
    right_inv := e.left_inv }

-- 等价的传递性
def equiv_trans {A B C : Type} (e₁ : Equiv A B) (e₂ : Equiv B C) : Equiv A C :=
  { to_fun := e₂.to_fun ∘ e₁.to_fun
    inv_fun := e₁.inv_fun ∘ e₂.inv_fun
    left_inv := fun x => 
      path_trans (path_trans (path_symm (e₂.left_inv (e₁.to_fun x))) 
                              (path_symm (e₁.left_inv x))) Path.refl
    right_inv := fun x => 
      path_trans (path_trans (e₁.right_inv (e₂.inv_fun x)) 
                              (e₂.right_inv x)) Path.refl }

-- 等价的群结构
theorem equiv_group_laws {A B C D : Type} :
  (e₁ : Equiv A B) → (e₂ : Equiv B C) → (e₃ : Equiv C D) →
  equiv_trans (equiv_trans e₁ e₂) e₃ = equiv_trans e₁ (equiv_trans e₂ e₃) :=
  fun e₁ e₂ e₃ => by
    -- 证明等价的结合律
    sorry
```

### 等价的计算 / Computation with Equivalence

```lean
-- 等价的应用
def apply_equiv {A B : Type} (e : Equiv A B) (a : A) : B :=
  e.to_fun a

-- 等价的逆应用
def apply_equiv_inv {A B : Type} (e : Equiv A B) (b : B) : A :=
  e.inv_fun b

-- 等价保持结构
def equiv_preserves_structure {A B : Type} (e : Equiv A B) 
  (f : A → A → A) (g : B → B → B) : Prop :=
  ∀ x y, e.to_fun (f x y) = g (e.to_fun x) (e.to_fun y)

-- 等价的不变量
def equiv_invariant {A B : Type} (e : Equiv A B) (P : A → Prop) : Prop :=
  ∀ x, P x ↔ P (e.inv_fun (e.to_fun x))
```

### 等价与同伦 / Equivalence and Homotopy

```lean
-- 同伦的定义
def homotopy {A B : Type} (f g : A → B) : Prop :=
  ∀ x, Path (f x) (g x)

-- 等价与同伦的关系
theorem equiv_homotopy {A B : Type} (e : Equiv A B) :
  homotopy (e.to_fun ∘ e.inv_fun) id ∧ homotopy (e.inv_fun ∘ e.to_fun) id :=
  ⟨fun x => e.right_inv x, fun x => e.left_inv x⟩

-- 同伦等价
def homotopy_equiv {A B : Type} (f : A → B) (g : B → A) : Prop :=
  homotopy (f ∘ g) id ∧ homotopy (g ∘ f) id

-- 从等价构造同伦等价
def equiv_to_homotopy_equiv {A B : Type} (e : Equiv A B) : 
  homotopy_equiv e.to_fun e.inv_fun :=
  ⟨fun x => e.right_inv x, fun x => e.left_inv x⟩
```

---

## 单值性公理 / Univalence Axiom

### 2核心定义 / Core Definition

**中文**：单值性公理（Univalence Axiom）是 HoTT 的核心公理，断言等价类型之间可以互换，将类型等价与类型等式统一起来。

**English**: The Univalence Axiom is a core axiom of HoTT, asserting that equivalent types can be identified/interchanged, unifying type equivalence with type equality.

### 公理陈述 / Axiom Statement

```lean
-- 单值性公理
axiom univalence {A B : Type} : Equiv (Equiv A B) (Path A B)

-- 单值性公理的函数形式
def univalence_fun {A B : Type} (e : Equiv A B) : Path A B :=
  univalence.to_fun e

-- 单值性公理的逆函数形式
def univalence_inv {A B : Type} (p : Path A B) : Equiv A B :=
  univalence.inv_fun p

-- 单值性公理的证明
theorem univalence_proof {A B : Type} (e : Equiv A B) :
  Path (univalence_inv (univalence_fun e)) e :=
  univalence.left_inv e

theorem univalence_proof_inv {A B : Type} (p : Path A B) :
  Path (univalence_fun (univalence_inv p)) p :=
  univalence.right_inv p
```

### 单值性的应用 / Applications of Univalence

```lean
-- 类型外延性
theorem type_extensionality {A B : Type} (e : Equiv A B) : Path A B :=
  univalence_fun e

-- 函数外延性
theorem function_extensionality {A B : Type} {f g : A → B} 
  (h : ∀ x, Path (f x) (g x)) : Path f g :=
  -- 使用单值性公理证明函数外延性
  sorry

-- 命题外延性
theorem proposition_extensionality {P Q : Prop} (h : P ↔ Q) : Path P Q :=
  -- 使用单值性公理证明命题外延性
  sorry

-- 集合外延性
theorem set_extensionality {A B : Type} (h : ∀ x, x ∈ A ↔ x ∈ B) : Path A B :=
  -- 使用单值性公理证明集合外延性
  sorry
```

### 单值性的计算性质 / Computational Properties of Univalence

```lean
-- 单值性的计算规则
def univalence_compute {A B : Type} (e : Equiv A B) (a : A) : B :=
  -- 单值性公理的计算性质
  match univalence_fun e with
  | Path.refl => e.to_fun a

-- 单值性的传输定理
def transport_univalence {A B : Type} (e : Equiv A B) (P : Type → Prop) 
  (h : P A) : P B :=
  -- 使用单值性公理进行类型传输
  match univalence_fun e with
  | Path.refl => h

-- 单值性的同伦性质
theorem univalence_homotopy {A B : Type} (e : Equiv A B) :
  homotopy (transport_univalence e (fun X => X → X)) (fun f => e.to_fun ∘ f ∘ e.inv_fun) :=
  -- 证明单值性公理的同伦性质
  sorry
```

---

## 高阶路径 / Higher Paths

### 2-路径 / 2-Paths

```lean
-- 2-路径的定义
def Path2 {A : Type} {a b : A} {p q : Path a b} : Type :=
  Path p q

-- 2-路径的群结构
def path2_group {A : Type} {a b : A} (p : Path a b) : PathGroup (Path a b) :=
  { carrier := Path p p
    unit := Path.refl
    mul := path_trans
    inv := path_symm
    assoc := fun α β γ => path_group_laws α β γ
    left_unit := fun α => by cases α; rfl
    right_unit := fun α => by cases α; rfl
    left_inv := fun α => path_inverse α
    right_inv := fun α => path_inverse (path_symm α) }

-- 2-路径的交换律
theorem path2_commutative {A : Type} {a b : A} {p q : Path a b} 
  (α β : Path2 p q) : path_trans α β = path_trans β α :=
  -- 在2-路径中，群是交换的
  sorry
```

### n-路径 / n-Paths

```lean
-- n-路径的递归定义
inductive PathN : Nat → Type → Type → Type where
  | base : ∀ A a, PathN 0 A a a
  | step : ∀ n A a b, Path (PathN n A a b) → PathN (n + 1) A a b

-- n-路径的群结构
def pathn_group (n : Nat) {A : Type} (a : A) : PathGroup (PathN n A a a) :=
  match n with
  | 0 => { carrier := PathN 0 A a a
           unit := PathN.base A a
           mul := fun p q => p  -- 0-路径是平凡的
           inv := fun p => p
           assoc := fun p q r => rfl
           left_unit := fun p => rfl
           right_unit := fun p => rfl
           left_inv := fun p => rfl
           right_inv := fun p => rfl }
  | n + 1 => path_group (PathN.base A a)
```

---

## ∞-范畴 / ∞-Categories

### 3基本概念 / Basic Concepts

```lean
-- ∞-范畴的定义
structure InfinityCategory where
  objects : Type
  morphisms : objects → objects → Type
  composition : ∀ {a b c}, morphisms a b → morphisms b c → morphisms a c
  identity : ∀ a, morphisms a a
  associativity : ∀ {a b c d} (f : morphisms a b) (g : morphisms b c) (h : morphisms c d),
    composition (composition f g) h = composition f (composition g h)
  left_unit : ∀ {a b} (f : morphisms a b), composition (identity a) f = f
  right_unit : ∀ {a b} (f : morphisms a b), composition f (identity b) = f

-- 从类型构造∞-范畴
def type_infinity_category : InfinityCategory :=
  { objects := Type
    morphisms := fun A B => A → B
    composition := fun f g => g ∘ f
    identity := fun A => id
    associativity := fun f g h => rfl
    left_unit := fun f => rfl
    right_unit := fun f => rfl }
```

### ∞-范畴与HoTT / ∞-Categories and HoTT

```lean
-- HoTT中的∞-群胚
structure InfinityGroupoid where
  objects : Type
  morphisms : objects → objects → Type
  composition : ∀ {a b c}, morphisms a b → morphisms b c → morphisms a c
  identity : ∀ a, morphisms a a
  inverse : ∀ {a b}, morphisms a b → morphisms b a
  -- 所有高阶结构都是可逆的

-- 从类型构造∞-群胚
def type_infinity_groupoid : InfinityGroupoid :=
  { objects := Type
    morphisms := fun A B => Equiv A B
    composition := equiv_trans
    identity := fun A => equiv_refl
    inverse := equiv_symm }
```

---

## 在Lean中的实现 / Implementation in Lean

### HoTT扩展 / HoTT Extensions

```lean
-- HoTT扩展的基本结构
structure HoTTExtension where
  path_type : Type → Type → Type
  equivalence : Type → Type → Type
  univalence : ∀ A B, Equiv (equivalence A B) (path_type A B)

-- 在Lean中实现HoTT
def lean_hott_extension : HoTTExtension :=
  { path_type := fun A B => A = B
    equivalence := Equiv
    univalence := univalence }
```

### 计算考虑 / Computational Considerations

```lean
-- 可计算的等价
def computable_equiv {A B : Type} (e : Equiv A B) : Prop :=
  -- 等价是否可计算
  sorry

-- 计算路径
def compute_path {A : Type} {a b : A} (p : Path a b) : a = b :=
  path_to_eq p

-- 计算传输
def compute_transport {A : Type} {a b : A} (p : Path a b) (P : A → Type) 
  (x : P a) : P b :=
  -- 计算路径传输
  sorry
```

---

## 工程实践 / Engineering Practice

### HoTT的应用 / Applications of HoTT

```lean
-- 代数结构的外延性
theorem group_extensionality {G H : Type} (e : Equiv G H) 
  (f₁ : G → G → G) (f₂ : H → H → H) :
  equiv_preserves_structure e f₁ f₂ → Path G H :=
  fun h => univalence_fun e

-- 拓扑空间的外延性
theorem topological_extensionality {X Y : Type} (e : Equiv X Y) :
  -- 拓扑空间的外延性
  sorry

-- 范畴的外延性
theorem category_extensionality {C D : Type} (e : Equiv C D) :
  -- 范畴的外延性
  sorry
```

### 性能优化 / Performance Optimization

```lean
-- HoTT计算的优化
def optimized_path_computation {A : Type} {a b : A} (p : Path a b) : a = b :=
  -- 优化路径计算
  path_to_eq p

-- 等价计算的缓存
def equivalence_cache : IO.Ref (HashMap String (Equiv Type Type)) :=
  IO.mkRef HashMap.empty

-- 路径计算的缓存
def path_cache : IO.Ref (HashMap String (Path Type Type)) :=
  IO.mkRef HashMap.empty
```

---

## 2025 规范对齐 / Alignment with Lean 4 (2025)

### 语法更新 / Syntax Updates

- HoTT扩展使用公理化方式引入
- 路径类型使用 `Path` 或 `=` 语法
- 等价使用 `Equiv` 结构
- 单值性公理使用 `axiom` 声明

### 性能改进 / Performance Improvements

- 更高效的路径计算
- 更好的等价计算
- 改进的传输算法

### 工具支持 / Tool Support

- 改进的HoTT工具
- 更好的同伦计算
- 增强的∞-范畴支持

---

## 版本兼容性 / Version Compatibility

### Lean 3 → Lean 4 迁移 / Migration from Lean 3 to Lean 4

```lean
-- Lean 3 HoTT语法
def lean3_hott (A B : Type) : A ≃ B → A = B :=
  -- Lean 3的HoTT语法
  sorry

-- Lean 4 HoTT语法
def lean4_hott (A B : Type) : Equiv A B → Path A B :=
  univalence_fun
```

### 主要变更 / Major Changes

1. **语法统一**：更统一的HoTT语法
2. **性能优化**：更好的计算性能
3. **工具支持**：改进的HoTT工具
4. **扩展管理**：更好的扩展管理

---

## 交叉引用 / Cross References

- [1.11-范畴论与类型理论](1.11-范畴论与类型理论.md) - 范畴论基础
- [1.10-语义模型完整版](1.10-语义模型完整版.md) - 语义模型
- [1.9-证明系统完整版](1.9-证明系统完整版.md) - 证明系统
- [1.8.2-依赖类型理论-完整版](1.8.2-依赖类型理论-完整版.md) - 依赖类型理论

---

## 参考资料 / References

### 经典文献 / Classical Literature

1. **Univalent Foundations Project** - "Homotopy Type Theory: Univalent Foundations of Mathematics" (2013)
2. **Vladimir Voevodsky** - "Univalent Foundations and Set Theory" (2014)
3. **Steve Awodey** - "Type Theory and Homotopy" (2010)

### Lean 相关 / Lean Related

1. **Lean 4 Reference Manual** - HoTT Extensions Section
2. **Mathlib4 Documentation** - HoTT Examples
3. **Lean Community** - HoTT Tutorials

### 在线资源 / Online Resources

1. **HoTT Book**: <https://homotopytypetheory.org/book/>
2. **Lean 4 Documentation**: <https://leanprover.github.io/lean4/doc/>
3. **Mathlib4 Docs**: <https://leanprover-community.github.io/mathlib4_docs/>

---

## 变更记录 / Change Log

### v2025-01-01

- 合并路径类型、等价和单值性公理文件
- 增加完整的HoTT理论背景
- 添加详细的代码示例
- 更新至Lean 4 (2025)规范
- 增加工程实践指导

---

*最后更新：2025-01-01*  
*版本：v2025-01-01*  
*状态：完整版*

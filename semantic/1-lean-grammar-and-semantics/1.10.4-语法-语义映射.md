# 1.10.4 语法-语义映射 / Syntax-Semantics Mapping

[返回目录](../CONTINUOUS_PROGRESS.md) | [上一节: 1.10.3-公理语义.md](1.10.3-公理语义.md)

---

## 1.10.4.1 核心定义 / Core Definition

**中文**：语法-语义映射描述形式语言的语法结构与其语义解释之间的对应关系，是模型论的核心内容。它建立了语法和语义之间的桥梁，为形式语言提供了严格的数学解释。

**English**: Syntax-semantics mapping describes the correspondence between the syntactic structure of a formal language and its semantic interpretation, which is a core topic in model theory. It establishes a bridge between syntax and semantics, providing rigorous mathematical interpretation for formal languages.

### 1.10.4.1.1 历史背景 / Historical Background

语法-语义映射的概念源于模型论，由Alfred Tarski在1930年代提出。它为解决形式语言的意义问题提供了数学基础，是现代逻辑学和计算机科学的重要工具。

### 1.10.4.1.2 核心思想 / Core Ideas

1. **解释函数**：将语法结构映射到语义对象
2. **组合性**：复杂表达式的语义由其组成部分的语义组合而成
3. **一致性**：语法规则与语义解释保持一致
4. **完备性**：语义解释能够覆盖所有语法结构

---

## 1.10.4.2 形式化模型 / Formal Model

### 1.10.4.2.1 解释函数 / Interpretation Function

解释函数 $\mathcal{I}$ 将语法结构映射到语义对象：

$$\mathcal{I} : \text{Syntax} \times \text{Model} \to \text{Value}$$

其中：

- $\text{Syntax}$ 是语法结构集合
- $\text{Model}$ 是语义模型集合
- $\text{Value}$ 是语义值集合

### 1.10.4.2.2 组合性原则 / Compositionality Principle

组合性原则要求复杂表达式的语义由其组成部分的语义组合而成：

$$\mathcal{I}[E_1 \circ E_2] = \mathcal{I}[E_1] \otimes \mathcal{I}[E_2]$$

其中 $\circ$ 是语法组合操作，$\otimes$ 是语义组合操作。

### 1.10.4.2.3 语法树映射 / Syntax Tree Mapping

语法树到模型的映射通过递归定义：

**叶子节点**：
$$\mathcal{I}[x] = \rho(x) \text{ 其中 } \rho \text{ 是环境}$$

**内部节点**：
$$\mathcal{I}[f(E_1, \ldots, E_n)] = \mathcal{I}[f](\mathcal{I}[E_1], \ldots, \mathcal{I}[E_n])$$

### 1.10.4.2.4 语义等价性 / Semantic Equivalence

两个表达式语义等价当且仅当它们在所有模型下都有相同的解释：

$$E_1 \equiv E_2 \iff \forall \mathcal{M}, \mathcal{I}[E_1]_{\mathcal{M}} = \mathcal{I}[E_2]_{\mathcal{M}}$$

---

## 1.10.4.3 Lean 代码示例 / Lean Code Example

### 1.10.4.3.1 基本解释函数 / Basic Interpretation Function

```lean
-- 语法结构
inductive Expr : Type
| var : String → Expr
| const : Nat → Expr
| add : Expr → Expr → Expr
| mul : Expr → Expr → Expr
| app : Expr → Expr → Expr
| lam : String → Expr → Expr

-- 语义模型
structure Model : Type where
  domain : Type
  functions : String → List Type → Type
  constants : String → Type

-- 环境
def Environment : Type := String → Type

-- 解释函数
def interpret : Expr → Model → Environment → Type
| Expr.var x, model, env => env x
| Expr.const n, model, env => Nat
| Expr.add e1 e2, model, env => 
  match interpret e1 model env, interpret e2 model env with
  | Nat, Nat => Nat
  | _, _ => Unit  -- 类型错误
| Expr.mul e1 e2, model, env => 
  match interpret e1 model env, interpret e2 model env with
  | Nat, Nat => Nat
  | _, _ => Unit
| Expr.app e1 e2, model, env => 
  match interpret e1 model env with
  | (α → β) => 
    if interpret e2 model env = α then β else Unit
  | _ => Unit
| Expr.lam x body, model, env => 
  let α := env x
  let β := interpret body model env
  α → β
```

### 1.10.4.3.2 组合性实现 / Compositionality Implementation

```lean
-- 组合性检查
def is_compositional (interpret : Expr → Model → Environment → Type) : Prop :=
  ∀ e1 e2 model env,
  interpret (Expr.add e1 e2) model env = 
  match interpret e1 model env, interpret e2 model env with
  | Nat, Nat => Nat
  | _, _ => Unit

-- 语义等价性
def semantic_equiv (e1 e2 : Expr) : Prop :=
  ∀ model env, interpret e1 model env = interpret e2 model env

-- 语义等价性证明
theorem add_comm_semantic (e1 e2 : Expr) :
  semantic_equiv (Expr.add e1 e2) (Expr.add e2 e1) := by
  intro model env
  simp [interpret, semantic_equiv]
  cases interpret e1 model env <;> cases interpret e2 model env <;> simp
```

### 1.10.4.3.3 语法树映射 / Syntax Tree Mapping

```lean
-- 语法树结构
inductive SyntaxTree : Type
| leaf : String → SyntaxTree
| node : String → List SyntaxTree → SyntaxTree

-- 语法树解释
def interpret_tree : SyntaxTree → Model → Environment → Type
| SyntaxTree.leaf x, model, env => env x
| SyntaxTree.node op children, model, env => 
  match op, children with
  | "add", [t1, t2] => 
    match interpret_tree t1 model env, interpret_tree t2 model env with
    | Nat, Nat => Nat
    | _, _ => Unit
  | "mul", [t1, t2] => 
    match interpret_tree t1 model env, interpret_tree t2 model env with
    | Nat, Nat => Nat
    | _, _ => Unit
  | "app", [t1, t2] => 
    match interpret_tree t1 model env with
    | (α → β) => 
      if interpret_tree t2 model env = α then β else Unit
    | _ => Unit
  | _, _ => Unit

-- 语法树到表达式的转换
def tree_to_expr : SyntaxTree → Expr
| SyntaxTree.leaf x => Expr.var x
| SyntaxTree.node "add" [t1, t2] => Expr.add (tree_to_expr t1) (tree_to_expr t2)
| SyntaxTree.node "mul" [t1, t2] => Expr.mul (tree_to_expr t1) (tree_to_expr t2)
| SyntaxTree.node "app" [t1, t2] => Expr.app (tree_to_expr t1) (tree_to_expr t2)
| _ => Expr.const 0  -- 默认情况
```

### 1.10.4.3.4 语义保持性 / Semantic Preservation

```lean
-- 语义保持性证明
theorem semantic_preservation (t : SyntaxTree) (model : Model) (env : Environment) :
  interpret (tree_to_expr t) model env = interpret_tree t model env := by
  induction t with
  | leaf x => 
    simp [tree_to_expr, interpret, interpret_tree]
  | node op children ih => 
    simp [tree_to_expr, interpret, interpret_tree]
    cases op <;> cases children <;> simp [ih]

-- 语义一致性
def semantic_consistency (interpret : Expr → Model → Environment → Type) : Prop :=
  ∀ e model env, 
  match interpret e model env with
  | Nat => True
  | Unit => False  -- 类型错误
  | _ => True

-- 语义完备性
def semantic_completeness (interpret : Expr → Model → Environment → Type) : Prop :=
  ∀ e model env, interpret e model env ≠ Unit  -- 所有表达式都有有效语义
```

### 1.10.4.3.5 实际应用示例 / Practical Application Examples

```lean
-- 算术表达式的语义解释
def arithmetic_interpret : Expr → Model → Environment → Nat
| Expr.var x, model, env => env x
| Expr.const n, model, env => n
| Expr.add e1 e2, model, env => 
  arithmetic_interpret e1 model env + arithmetic_interpret e2 model env
| Expr.mul e1 e2, model, env => 
  arithmetic_interpret e1 model env * arithmetic_interpret e2 model env
| _, _, _ => 0  -- 默认情况

-- 布尔表达式的语义解释
def boolean_interpret : Expr → Model → Environment → Bool
| Expr.var x, model, env => env x
| Expr.const n, model, env => n ≠ 0
| Expr.add e1 e2, model, env => 
  boolean_interpret e1 model env || boolean_interpret e2 model env
| Expr.mul e1 e2, model, env => 
  boolean_interpret e1 model env && boolean_interpret e2 model env
| _, _, _ => false  -- 默认情况

-- 语义等价性测试
def test_semantic_equiv : Prop :=
  let e1 := Expr.add (Expr.const 1) (Expr.const 2)
  let e2 := Expr.add (Expr.const 2) (Expr.const 1)
  ∀ model env, arithmetic_interpret e1 model env = arithmetic_interpret e2 model env

-- 证明语义等价性
theorem test_equiv_proof : test_semantic_equiv := by
  intro model env
  simp [arithmetic_interpret]
  rw [Nat.add_comm]
```

---

## 1.10.4.4 交叉引用 / Cross References

- [1.10-模型论与语义模型.md](1.10-模型论与语义模型.md)

---

## 1.10.4.5 2025 规范对齐 / Alignment with Lean 4 (2025)

- 建议以可执行/可验证的 Lean 代码表达“解释函数”与“语法树到模型映射”的接口与不变式。
- 分离可计算部分与 `Prop` 级性质声明；证明不参与计算路径。
- 示例应包含必要 `import` 并能 `#eval` 或经 `example` 验证。

---

## 1.10.4.6 版本兼容性 / Version Compatibility

- 旧版 `notation`/宏定义迁移至 `syntax`/`macro_rules`。
- 若依赖 mathlib4 之模型论构件，需标注 `import Mathlib` 对应模块并说明版本。

---

## 1.10.4.7 参考资料 / References

- Lean 4 Reference Manual（语义、宏与 elaboration 章节）
- 模型论入门教材与语义学讲义（作为背景理论）
